# Chapter 13. 분산 트랜잭션

트랜잭션 처리의 핵심은 가능한 이력을 선택하고 교차 수행 시나리오를 모델링 및 정의하는 것이다.

동일한 트랜잭션을 순차적으로 수행하는 또 다른 이력이 존재하는 경우 해당 이력은 직렬화할 수 있다고 표현한다.

트랜잭션이란 여러 작업의 집합이고 원자적 단위다. 원자성을 보장하기 위해 트랜잭션은 복구 가능해야 한다.

## 원자석 연산처럼 수행하기

Atomic commitment는 참가 노드 사이의 의견 불일치를 허용하지 않는다. 단 한 노드라도 동의하지 않는다면 트랜잭션을 커밋할 수 없다. (비정상 프로세스도!)

- 원자적 커밋 문제는 해결될 수 있지만 코디네이터 프로세스의 장애를 허용하지 않는 : 2 Phase Commit
- 논블로킹 원자적 커밋 문제를 해결하고 코디네이터의 장애를 허용하는 : 3 Phase Commit

## 2PC

상태를 저장하고 의견을 수렴하는 합의 과정의 기준점이 되는 리더, 나머지 노드는 cohort

일반적으로 Cohort는 트랜잭션에서 접근하는 데이터가 저장된 서로 겹치지 않는 파티션

- 준비 : 코디네이터가 Prepare를 코호트에 전달, 코호트는 커밋 여부를 결정. 커밋이 가능하다면 동의하고 불가능하다면 트랜잭션 중단 요청
- 커밋/중단 : 단 하나의 코호트라도 트랜잭션 중단을 요청한다면 Abort 전달.

코디네이터와 코호트는 로컬 상태를 재구성하고 장애 발생시 복구할 수 있도록 모든 단계마다 결과를 영구적으로 저장, Replay가 가능해야 함

2PC의 각 라운드는 하나의 트랜잭션을 수행하고, 준비 단계에서 연산, 식별자, 메타데이터 등 트랜잭션 내용을 전달한다. 따라서 커밋 시점에 관련 레코드는 이미 모든 노드에 저장돼 있다.

### 2PC의 Cohort 장애 처리

코호트 장애 발생이 곧 트랜잭션의 실패를 의미하기 때문에 가용성이 낮아지게 된다. 

코호트 장애 발생 시 코디네이터의 최종 결정에 따라 코호트를 기다렸다가 동기화하거나 타임아웃을 트리거하거나 트랝개션을 중단하게 된다.

(서로를 무한정 기다리게 될 수 있기 떄문)

### 2PC의 Coordinator 장애 처리

코디네이터가 트랜잭션의 커밋 또는 중단을 진행할 수 없는 경우 클러스터는 미확정 상태에 이르게 되며, 후임 코디네이터가 해당 트랜잭션의 진행 여부에 대한 의견을 다시 수렴한다.

MySQL, PostgreSQL, MongoDB 등의 데이터베이스가 2PC를 사용한다. 단순하고, 오버헤드가 적기 때문인데, 장애 발생 상황에 대응하기 위해 알맞은 복구 메커니즘과 백업 코디네이터 노드가 필요하다.

## 3PC

3PC를 사용하면 코디네이터 장애에 견고하게 대응하고 미확정 상태를 피할 수 있다.

3PC는 2PC처럼 반드시 코디네이터가 존재해야 하며, 코호트에 타임아웃을 설정한다.

- 제안 : 코디네이터는 코호트에 제안 값을 전달하고 의견을 수집
- 준비 : 코호트에 수렴 결과를 알리고, Prepare 메시지를 ㅌ오해 커밋을 준비하도록 지시
- 커밋 : 트랜잭션 커밋 지시

모든 코호트가 커밋 준비를 완료하고 코디네이터는 코호트의 확인 응답을 받는 즉시 어느 한 쪽에 장애가 발생해도 트랜잭션은 커밋된다.

왜? 이 시점에 모든 코호트의 상태는 동일하기 때문.

### 3PC의 Coordinator 장애 처리

3PC는 프로세스를 블록하지 않고 코호트가 알아서 작업을 진행하게 되며, 타임아웃을 통해 코호트가 미확정 상태를 겪지 않고 트랜잭션을 중단시킬 수 있다.

3PC에서 최악의 상황은 네트워크 파티션이 발생한 경우인데, 일부 코호트는 트랜잭션을 커밋하고 일부는 중단하는 Split brain 현상이 일어날 수 있다.

이론적으로 3PC는 2PC의 블로킹 문제를 해결할 수 있으나, 메시지 오버헤드가 더 크고 일관성을 보장하지 않으며 네트워크 파티션 발생 시 제대로 작동하지 않기 때문에 많이 사용되지 않는다.

## 칼빈의 분산 트랜잭션

경합과 트랜잭션의 잠금 소유 시간을 줄일 수 있는 여러 방법이 존재

잠금을 획득하고 연산을 수행하기 전에 복제 노드 사이에 실행 순서와 트랜잭션의 범위를 미리 결정 -> 한 노드에 장애가 발생해도 다른 노드로부터 복구가 가능

실행 순서가 정해진 경우 모든 복제 노드의 인풋, 아웃풋이 일관적이기 때문에 실행 단계에서 코디네이션 비용이 필요하지 않으며 -> Calvin 알고리즘이라 부름. FaunaDB가 대표적.

Epoch로 타임라인을 분할하여 경합, 배치를 최소화.

- 트랜잭션 진입점 역할을 하는 Sequencer : 트랜잭션 실행 순서 결정 , 시퀀스 생성.
- 트랜잭션 수행을 감독하는 스케줄러 : 시퀀서가 정의한 순서를 유지하면서 일부를 병렬로 수행
  - 칼빈의 트랜잭션은 읽기 세트(트랜잭션에서 사용되는 데이터 레코드의 집합)와 쓰기 세트(트랜잭션 결과)로 구성

스케줄러의 워커 스레드 작동

1. 트랜잭션 읽기, 쓰기 세트를 분석해 읽기 세트에서 로컬 레코드를 찾고 활성 노드(해당 레코드를 수정할 노드) 목록을 작성
2. 트랜잭션을 수행하는 데 필요한 로컬 레코드를 수집하고, 이를 활성 노드에 전달
3. 워커 스레드가 활성 노드에서 실행 중이라면, 다른 노드로부터 2단계의 결과를 전달 받음 ->???
4. 마지막으로 트랜잭션 배치를 수행하고 결과는 로컬 스토리지에 저장. 각 노드는 동일한 인풋으로 트랜잭션을 숳애하고 로컬에 결과를 저장하기 떄문에 결과 전달은 필요 없음.

## 스패너의 분산 트랜잭션

CockroachDB, YugaByteDB가 대표적.

스패너는 각 파티션(샤드)의 합의 그룹별로 2PC 프로토콜을 사용해 트랜잭션을 처리한다.

일관성과 트랜잭션 순서 보장을 위해 True Time 사용.

- 읽기-쓰기 트랜잭션
- Read Only Transcation
- Snapshot 읽기

를 지원.

구조는 각 스팬서버들이 여러 state machine, table의 쌍으로 구성.

복제 노드는 데이터 배치, 복제의 최소 단위인 팍소스 그룹이라는 복제 노드 집합으로 나뉘며, 리더는 멀티샤드 트랜잭션 수행 시 서로 통신한다.

모든 쓰기 요청은 팍소스 그룹 리더를 거쳐가며, 읽기 요청은 최신 상태의 복제 노드의 태블릿이 처리한다.

스패너는 개별 코호트가 아니라 팍소스 그룹을 통해 2PC의 정상 작동 가용성을 높인다.

## 데이터베이스 파티셔닝

가장 단순 방법 : 데이터를 여러 범위로 분할하고 복제 노드 세트에 특정 범위(파티션)만 저장. 쿼리 수행 시 라우팅 키에 해당하는 복제 노드 세트로 라우팅. 이처럼 데이터의 특정 범위를 저장하는 방식 == 샤딩

효율적 파티션에 대한 고민이 필요 : Hot, Cold

Resharding, Auto-sharding에 대한 고민

### 일관된 해싱

아파치 카산드라와 리악 : 리샤딩시 필요한 재배치 횟수를 줄이기 위해 이를 사용. 노드 추가 또는 제거 시에 클러스터 전체가 아닌 인접 노드만이 영향을 받음

해시 함수가 반환한 라우팅 키의 해시 값을 링에 매핑하고, 링은 크기 순서로 정렬되어 있으며 가장 큰 값 다음 가장 작은 값이 오도록 되어 있음.

-> 이것도 링의 특정 부분에 Skewed 될 수 있음. 따라서 가상 복제본 등을 통해 해결한다고 함

Jump Consistent Hash 같은 구현도 존재 : https://www.popit.kr/jump-consistent-hash


## 퍼콜레이터의 분산 트랜잭션 처리

Snapshot Isolation(트랜잭션 내에서 읽은 값이 데이터베이스의 스냅숏과 일치하도록 보장)이라는 트랜잭션 모델을 사용해 쓰기 이상 현상을 방지할 수도 있다.

쓰기-쓰기 충돌 시 하나의 쓰기만 커밋(First commit wins)

유용한 특성

- 오직 커밋된 데이터만 repeatable read를 허용 
- 특정 타임스탬프 시점의 스냅숏을 읽기 때문에 일관성이 보장
- 일관성 유지를 위해 충돌 발생 시 쓰기 중단 후 재시도

그럼에도 SI의 이력은 직렬화 될 수 없으며, 같은 셀에 충돌하는 작업만 중단하기 떄문에 쓰기 쏠림은 발생 가능

Percolator는 기존 시스템 위에 트랜잭션 API를 구현할 수 있는 좋은 방법.

데이터 레코드와 커밋된 데이터의 위치를 저장하고 칼럼 단위 잠금을 제공한다.

트랜잭션 시작과 커밋 시 타임스탬프를 요청하고, 쓰기 작업의 결과는 2PC를 통해 버퍼링 및 커밋한다.

## 코디네이션 생략

직렬화의 비용을 줄이고 높은 일관성을 보장하면서 코디네이션 비용을 줄이기 위해 코디네이션을 생략할 수도 있다.

불변 속성의 두 상태를 병합하여 유효하게 만드는 것

단, 다음 속성을 보장해야 함

- 유효성 : 병합된 데이터베이스 상태는 모두 불변 조건을 충족해야 하며, 트랜잭션은 절대 유효하지 않은 상태를 읽을 수 없다.
- 가용성 : 클라이언트가 상태가 저장된 모든 노드에 연결할 수 있는 경우 트랜잭션 커밋 여부에 대해 합의해야 한다.
- 수렴 : 각 노드는 각자의 상태를 유지하며, 타 트랜잭션이 없거나 무기한 네트워크 파티션이 발생하지 않는다면 같은 상태로 수렴할 수 있어야 한다.
- 코디네이션 생략 : 로컬 트랜잭션은 다른 노드를 대신에 로컬 상태에 대해 수행한 작업과 독립적이다.

e.g. RAMP(Read-Atomic Multi Partition) Transaction


