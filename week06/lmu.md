# 10장 리더 선출
- 일반적으로 분산 시스템의 프로세스는 균일하고 모든 프로세스가 리더 역할을 맡을 수 있다.
- 리더 프로세스는 오랫동안 리더 역할을 유지하지만 영구적이지는 않다.
- 리더 프로세스는 브로드캐스트된 메시지의 순서를 유지한다.
- 선출 작업은 시스템 초기화 시 첫 리더를 선출하기 위해 또는 리더 프로세스가 충돌하거나 장애가 발생했으 때 발동된다.
- ZAB, Multi-Paxos, Raft 는 임시리더를 선출해 참가자간 합의를 도출하는 데 필요한 메시지 수를 줄인다.

## 불리 알고리즘(bully algorithm)
- 단계:
  1. 프로세스는 자신보다 높은 순위의 프로세스에 선출 메시지를 보낸다.
  2. 상위 순위 프로세스가 응답할 때까지 대기하고 응답이 없으면 다음 단계를 진행한다. 응답하는 경우 자신이 알고 있는 최상위 프로세스에 다음 단계 진행을 요청한다.
  3. 프로세스는 자신보다 더 높은 순위의 프로세스가 없다고 가정하고 하우 ㅣ프로세스에 새로운 리더가 선출된 사실을 알린다.

## 다음 서열로 리더 역할 승계
- 여러 대안 프로세스를 두고 장애 조치시 리더 역할을 승계해 재선출 작업을 단축할 수 있다.

## 후보/일반 노드 최적화
- 후보 그룹과 일바 ㄴ그룹으로 나누고 특정 후보 노드를 리더로 선출하는 알고리즘

## 초대 알고리즘
- 서로 더 높은 순위를 차지하기 위해 경쟁하는 대신 서로 자신의 그룹으로 초대한다.

## 링 알고리즘
- 모든 노드는 링 형태로 연결돼 있고 각 노드는 링의 토폴로지에 관한 정보를 가지고 있다.
- 각 노드의 형제 노드를 방문하면서 링을 순회하면 정상 노드에 대한 정보를 수집할 수 있다.
- 노드는 자신을 정상 노드 목록에 추가하고 다음 노드로 이동한다.

## 요약
- 리더를 선출하면 조정 오버헤드를 줄일 수 있고 알고리즘으 ㅣ성능을 높일수 있다.
- 선출 작업은 비용이 높은 작업이지만, 자주 수행되지 않기 때문에 시스템 성능에 큰 영향을 주지 않는다.
- 단일 리더 프로세스는 병목이 될 수 있다.
- Split Brain 현상을 일으킬 수 있다. 과반수 동의가 필요하다.
- Multi-paxos, Raft 를 비롯한 여러 합의 알고리즘은 리더 프로세스가 조율을 담당한다.
- 리더의 정채는 프로세스가 모르는 사이에 바뀔 수 있다. 따라서 각자 주기적으로 리더에 대한 정보가 유효한지 확인해야 한다.
- 현재 리더에 장애가 발생하면 새로운 리더를 선출하는 지속성을 위해 계속해서 리더를 선출한다.

# 11장 복제와 일관성
- 내결함성: 장애가 발생해도 정상적으로 작동할수 있는 시스템 속성
- 단일 장애점: Single Point of Failure
- Fail over
- Source of Truth
- 지리적 이중화

## 고가용성
- 시스템 가용성은 중요한 요소이다.
- 고가용 시스템은 일부 노드의 장애 및 오류를 단계적으로 대응할 수 있어야한다.

## CAP 이론
- 네트워크 파티션이 발생해도 일관성과 가용성을 모두 충족하는 시스템을 구축하는 방법은 없다.
- 가용성: 모든 정상 노드는 결과를 반환한다.
- 일관성: 모든 결과는 선형화 할수 있다.
- CAP: Consistency, Availability, Partition tolerance
- 비동기 시스템에서는 가용성을 보장할 수 없다.
- 선택지:
  - 높인 일관성과 분할 허용: CP 시스템은 요청을 정상적으로 처리하는 것보다 일관된 데이터를 제공하는 것을 더 중요시한다.
  - 가용성 보장 및 파티션 허용: AP 시스템은 일관성을 일부 포기하고 일관되지 않은 데이터를 제공할 수 있다.
- PACELEC 정리: CAP 이론을 확장해 네트워크 파티션 발생시 가용성과 일관성 중 하나를 선택해야 하고, 나아가 시스템이 정상적으로 작동하더라도 레이턴시와 일관성 중 하나를 선택해야한다.

## CAP 이론의 특성
- 노드 충돌 또는 다른 종류의 장애보다 네트워크 파티션만을 다룬다.
- 모든 노드가 정상적으로 가동 중이어도 노드 간의 연결 문제가 있으면 일관성 문제가 발생할 수 있다.
- 분할 내성은 현실적으로 튜닝 또는 다른 속성과 맞바꿀 수 없는 속성이다.
- CAP 이론은 하나의 법칙일 뿐이고 모든 경우를 설명하지 않는다.

## 수확률과 산출률
- 수확률: 쿼리 결과의 완전성
- 산출률: 전체 요청 중 성공적으로 완료된 요청 수

## 공유 메모리
- 세이프 레지스터: 쓰기 중인 세이프 레지스터를 동시에 읽으면 레지스터에 저장된 값의 범위 내에서 임의의 값을 반환할 수 있다.
- 일반 레지스터: 가장 최신 값 또는 동시 수행 중인 쓰기 작업이 쓴 값을 반환한다.
- 원자적 레지스터: 선형화 가능성을 보장한다.

## 순서화
- 수행 순서를 이해하고 결과를 정확하게 추론하기 위해서는 일관성 모델을 정의해야한다.

## 일관성 모델
- 여러 일관성 모델은 서로 시맨틱과 보장하는 속성이 다르다.
- 일관성을 상태 관점에서 생각하면, 허용되는 상태를 규정하고 같은 데이터 복제본 사이에 허용되는 관계를 정의하는 속성이다.
- 이론적으로 시스템 레벨의 잠금을 획득하면 되지만, 비효율적이다.

## 엄격한 일관성 모델
- 복제가 완전히 투명한 모델
- 이론적으로 존재하며 현실적으로 구현이 불가능하다.

## 선형화 가능성
- 동시 수행 연산의 수행 순선에는 어느 정도 유연성이 존재하지만 아무렇게나 재배치할 수 없다.
- 선형화 지점:
  - 가시성: 작업이 완료되면 모두가 결과를 볼 수 있어야 하고, 시스템은 수정 사항을 다시 되돌리거나 일부 참가자로부터 숨길 수 없다.
  - 크테일 읽기를 방지하고 단조 읽기만을 허용한다.
- 선형화 비용:
  - CAS 연산을 사용해 구현할 수 있다.
  - 분산 시스템에서 선형화는 조정과 순서화가 필요하다.

## 순차 일관성 모델
- 각 프로세스가 실제로 연산을 수행한 순서를 그대로 유지하면서 모든 연산이 어떤 순차적인 차례로 실행된 것처럼 보이도록 한다.
- 원래 멀티 프로세스 기반 프로그램에서 동시성을 처리하는 방식을 규정하기 위해 고안된 모델이다.
- 메모리 베리어, 펜스

## 인과적 일관성 모델
- 논리적 시간
- 논리적 클럭과 모든 메시지마다 논리적으로 선행돼야하는 작업에 대한 메타데이터를 추가해 구현
- 새로운 요청에는 항상 최신 버전의 메타데이터가 포함되어 있다.
- 순서 보존 서버 클러스터(COPS, Clusters of Order-Preserving Server)와 아이거(Eiger)는 인과적 일관성을 구현한 대표적인 프로젝트이다.

### 벡터 클럭
- 인과 순서를 정의
- 이벤트 간의 부분 순서를 정의하고 여러 부분 순서 사이의 불일치를 해결하는 데 사용
- 공유 시간과 전역 상태를 구현 - 비동기 이벤트를 동기 이벤트로 나타낼수 있다.
- 가용성과 성능을 모두 충족하는 일관성 모델은 스테일 읽기 뿐만 아니라 충돌이 발생할 수 있는 쓰기 작업도 허용하기 때문에 모든 복제본이 완전히 일치하지 않을 수 있다.

## 세션 모델
- 클라이언트 중심 일관성 모델이라고 부르기도 한다.
- 단조 일기와 쓰기, 쓰기 후 읽기, 읽기 후 쓰기가 세션에서 보장된다.
- PRAM 일관성 FIFO 일관성
- 시스템을 검증 및 단순화하기 위해 클라이언트 중심 일관성 모델을 선택한다.

## 결과적 일관성
- 변경 사항은 시스템에서 비동기적으로 전파되고, 데이터가 더 이상 변경되지 않은 다면 결과적으로 모든 읽기는 가장 최신 값을 반환한다.
- 충돌이 발생하는 경우 마지막쓰기 채택 또는 벡터 클럭 사용등에 따라 최신 값의 개념이 달라질수 있다.

## 조정 가능한 일관성
- 복제 팩터 N: 데이터 복제본을 저장하는 노드 수
- 쓰기 일관성 W: 쓰기가 성공하기 위해 응답해야 하는 노드 수
- 읽기 일관성 R: 읽기가 성공하기 위해 값을 반환해야 하는 노드 수
- R + W > N 을 충족하는 일관성 수준은 읽기와 쓰기 작업 사이에 겹치는 노드가 항상 존재하기 떄문에 최신 값을 반환한다.

## 증명 복제 노드
- 감시 복제 노드 개념을 사용해 저장 비용을 낮춘다.
- 카피 노드에 장애 또는 쓰기 타임아웃이 발생하면 감시 노드를 카피 노드로 업그레이드하고 레코드를 임시 저장한다. 노드가 복구 되면, 업그레이드된 감시 노드를 이전 상태로 되돌리거나 복구된 노드를 감시 노드로 사용한다.

## 강력한 결과적 일관성과 CRDTs
- 어느 정도의 비일관성을 허용하고 일치하지 않는 상태는 수행 후 조정할 수 있도록 연산마다 상태를 추가로 저장할 수 있다.
- CRDTs는 복제 노드 사이의 일시적 불일치를  허용하기 때문에 결과적 일관성 기반 시스템에서 유용하다
- CmRDTs:
  - 부가 효과 없음: 연산 수행이 시스템 상태를 변경하지 않는다.
  - 순서 무관
  - 인과 순서 존재: 전제 조건이 충족됐을 떄 연산을 수행할 수 있다. 따라서 연산 수행 시 시스템은 특정상태에 도달했음이 보장된다.
- 순서가 없는 추가 전용집합도 CRDTs 를 사용해 구현할 수 있다.
- 충돌이 발생하지 않는 복제된 JSON 타입은 더 복잡한 형태의 CRDTs이다.
