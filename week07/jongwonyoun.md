- [12장. 안티-엔트로피와 배포](#12---)
    - [읽기 복구](#-)
    - [다이제스트 읽기](#-)
    - [힌트 핸드오프](#-)
    - [머클 트리](#-)
    - [비트맵 버전 벡터](#--)
    - [가십 전파](#-)
        - [가십 메커니즘](#-)
        - [오버레이 네트워크](#-)
        - [혼합형 가십 프로토콜](#--)
        - [부분 뷰](#-)
    - [요약](#)

# 12장. 안티-엔트로피와 배포

- 1:1 또는 1:N 구조의 경우 데이터 레코드를 안정적으로 전파하기 위해서는 전파하는 노드가 사용 가능한 상태여야 하고 다른 노드와 통신할 수 있어야 한다
- 따라서 단일 노드의 성능이 처리율을 결정한다


- 클러스터 메타데이터는 데이터 레코드보다 더 빠르고 안정적으로 전달되어야 한다
- 보통 데이터 레코드보다 크기가 작고 자주 전송되지 않지만 빠르고 안정적으로 전달될 필요가 있다


- 크게 세 가지 통신 패턴이 있다
    - 하나의 프로세스가 브로드캐스트
    - P2P 방식
    - 모든 수신자가 협력해 브로드캐스트


- 노드가 적으면 단일 프로세스 브로드캐스트가 제일 간단하다
- 하지만 노드가 많으면 통신 비용이 증가하고, 단일 프로세스 의존성이 늘어나 안정성이 줄어든다
- 또한 모든 프로세스 목록을 항상 가지고 있을 수는 없다
- 또한 한 노드가 각 노드와 통신할 수 있는 지점이 반드시 존재해야 하는게 그게 어려울 수도 있다


- 이런 조건을 완화하고, 일부 업데이트 내역이 전파되지 않을 수 있다고 가정할 수 있다
- 최대한 많은 메시지를 전달하되, 장애 발생 시 안티-엔트로피(anti-entropy) 메커니즘을 통해 노드를 최신 상태로 유지한다


- 엔트로피는 노드 사이의 불일치 정도를 나타낸다


- 안티-엔트로피 메커니즘은 기본 전송이 실패했을 때 노드를 최신 상태로 동기화한다
- 코디네이터에 장애가 발생해도 다른 정상 노드가 계속해서 정보를 전파하기 때문에 문제 없이 작동한다
- 떡분에 시스템의 동기화 시간을 단축시킬 수 있다

## 읽기 복구

- 복제본 사이의 차이는 읽는 동안 감지하는게 가장 쉽다
- 성능을 위해 클라이언트가 요청한 레코드만 확인한다


- 모든 복제본이 동기화된 상태라고 가정하고, 노드 상태가 일치하지 않는 경우 누락된 변경 사항을 복제 노드로 전송한다
- 이를 읽기 복구(read repair)라고 한다


- 다이나모 방식의 일부 데이터베이스는 모든 복제 노드에 질의하지 않고 일관성 수준을 조정하낟
- 모든 복제 노드 대신 일관성 수준을 달성하는 데 필요한 수의 노드에만 질의한다


- 읽기 복구는 블로킹 작업 또는 비동기 작업으로 구현할 수 있다
- 블로킹 읽기 복구
    - 쿼럼의 단조 읽기를 보장
    - 복제 노드가 요청을 확인할 때까지 기다려야 하므로 가용성이 낮아진다
- 비동기 방식
    - 단조 읽기를 보장하지 않는다


- 일부 데이터베이스(카산드라 등)은 특수 반복자와 병합 리스너(merge listener)를 사용해 복제본 사이에 정확히 어떤 레코드가 누락됐는지 파악한다


- 대부분 복제 노드가 동기화된 상태라고 가정하기 때문에 모든 요청이 블로킹 읽기 복구를 발동시키진 않는다
- 단조 읽기를 보장하므로 요청 사이에 새로운 값을 쓰지 않는다면 연속된 읽기 요청은 동일한 결과를 반환한다

https://cassandra.apache.org/doc/latest/cassandra/operating/read_repair.html

https://javadoc.io/static/org.apache.cassandra/cassandra-all/3.11.4/org/apache/cassandra/db/rows/UnfilteredRowIterators.MergeListener.html
Interface for a listener interested in the result of merging multiple versions of a given row.

Implementors of this interface are given enough information that they can easily reconstruct the difference between the
merged result and each individual input. This is used when reconciling results on replias for instance to figure out
what to send as read-repair to each source.

## 다이제스트 읽기

- 모든 노드에게 읽기 요청을 보내는 대신 한 노드에만 원본 요청을 보내고 다른 복제 노드에는 다이제스트(digest)를 요청할 수 있다
- 모든 다이제스트가 일치하면 모든 복제 노드는 동기화된 상태라 확신할 수 있다


- 다이제스트가 불일치할 경우 어떤 노드가 최신 상태인지 알 수 없다
- 다이제스트가 일치하지 않은 복제 노드에 전체 읽기를 요청하고, 데이터를 비교한 뒤에 누락된 부분을 전송한다

## 힌트 핸드오프

- 힌트 핸드오프(hinted handoff)는 쓰기 중 상태를 복구하는 안티-엔트로피 메커니즘을 뜻한다
- 대상 노드가 쓰기 요청에 응답하지 않으면 코디네이터나 복제 노드 중 하나에 특수 힌트(hint) 레코드를 저장한다
- 노드가 복구되면 힌트 레코드를 참조해 쓰기를 재시도한다


- 리악과 같은 데이터베이스는 슬로피 쿼럼(sloopy quorum)과 힌트 핸드오프 방식을 사용한다
- 일부 복제 노드에 장애가 발생한 경우 전체 노드 목록에서 다른 정상 노드를 선택해 읽기를 수행한다
    - 복제 노드가 복구되면 힌트 레코드를 통해 복구하고, 힌트 레코드를 삭제한다


- 하지만 네트워크 파티션이 발생한 경우 일부 노드는 최신 값을 반환하지 않는다
- 즉, 고가용성을 위해 일관성을 포기한다

## 머클 트리

- 어떤 레코드가 다른지 비교하는 것은 꽤나 무거운 작업이다
- 이 비용을 줄이기 위해 머클 트리(Merkle Trees)를 사용한다


- 최하위 레벨에는 데이터 범위의 해시 값을 저장하고, 상위 레벨에는 하위 레벨 해시 값의 해시 값을 저장한다
- 덕분에 해시 값을 비교해 불일치를 빠르게 검사할 수 있다


- 다만, 데이터가 변경되면 해당 서브트리를 다시 계산해야 한다
- 트리의 크기와 정확도 사이에 트레이드-오프가 존재한다

## 비트맵 버전 벡터

- 비트맵 버전 벡터(bitmap version vector)는 최근성(recency)을 기반으로 데이터 사이의 불일치를 해결한다
- 각 노드는 로컬에서 수행한 작업과 다른 노드에서 복제한 데이터에 대한 로그를 저장한다
- 안티-엔트로피 단계에서 두 노드의 로그를 비교해 누락된 데이터를 해당 노드에 복제한다


- 각 노드의 복제본 상태는 노드별 논리적 클럭을 사용해 추적할 수 있다
- 각 클럭은 직접 알고 있는 쓰기 연산(자기가 코디네이션한 것) 또는 간접적으로 알게 된 쓰기 연산(다른 노드가 코디네이션해서 복제된 것)을 나타내는 닷(dot)들의 집합이다


- 닷을 통해 누락된 레코드를 찾은 경우, 이를 재생성하기 위해 DCC(Dotted Causal Container)에서 정보를 가져온다


- 이렇게 하면 쓰기 작업 사이의 인과관계를 파악해 충돌을 해결할 수 있다


- 이 방식의 장점은 쓰기 작업 사이의 인과관계와 노드 사이에 누락된 데이터를 정확히 파악할 수 있다는 점이다
- 단점은 일부 노드에 장애가 발생하게 되면 데이터가 장애 노드들에 복제되는 중이기 때문에 이들이 복구될 때까지 다른 노드들은 로그를 삭제할 수 없다

## 가십 전파

- 가십(gossip) 프로토콜은 브로드캐스트의 전파력과 안티-엔트로피의 신뢰성을 모두 갖추었다
- 이를 이용하면 변경사항을 모든 노드에 전파할 수 있다


- 가십 프로토콜의 주목적은 하나의 프로세스에서 클러스터 전체로 정보를 협동해서 전파하는 것이다


- 감염 상태(infective) : 전파된 프로세스
- 감염 대상 상태(susceptible) : 아직 전파되지 않은 프로세스
- 회복 상태(removed) : 전파를 중단하는 경우


- 데이터가 전파되었다는 사실이 확실해지면 감염 프로세스는 회복 상태가 된다


- 가십 프로토콜의 효율성은 메시지 중복을 최소화하면서 얼마나 빠르게 많은 노드에 데이터를 전파할 수 있는지에 따라 결정된다


- 노드가 클러스터 내에 단기적으로 존재하고, 토폴로지에 포함되지 않는 동질적 탈중앙 시스템에서 비동기적으로 메시지를 전달할 때 사용할 수 있다
- 직접적인 코디네이션이 필요 없어 노드가 자유롭게 추가 및 제거되는 시스템 또는 메시(mesh) 네트워크에서 유용할 수 있다


- 가십 프로토콜은 매우 견고해 분산 시스템에 자애가 발생해도 높은 신뢰성을 유지할 수 있다
- 일부 노드 사이에 통신 문제가 발생해도 다른 경로를 통해 전달될 수 있다
    - 경로가 고정되어 있지 않다

### 가십 메커니즘

- 주기적으로 `f`개의 임의의 노드를 선택하고 데이터를 교환한다 -> 팬아웃
- 같은 메시지가 반복적으로 여러 노드 사이에 전파되는 상황이 발생할 수 있다


- 메시지 중복성(redundancy)은 같은 메시지를 반복해서 전달해 발생하는 오버헤드를 나타낸다


- 시스템이 수렴에 도달하는 데 걸리는 시간을 레이턴시라고 한다
- 수렴과 모든 노드에 메시지를 전달하는 것은 같지 않다
    - 메시지가 다 전달되어도 가십은 짧은 시간 동안 계속해서 전파될 수 있다
- 대규모 시스템에서 레이턴시를 적정선으로 유지하기 위해서는 팬아웃을 높게 설정해야 한다


- 전파 여부는 확률이나 임계값을 기반으로 결정할 수 있다
    - 확률 : 각 단계마다 전파 중단 확률 계산
    - 임계값  :중복 메시지의 수가 일정 수를 넘으면 전파 중단


- 두 방법 모드 클러스터 크기와 팬아웃을 고려해야 한다
- 중복 횟수를 기반으로 전파 완료 여부를 판단하면 레이턴시와 중복을 줄일 수 있다


- 가십 프로토콜은 수렴적(convergent) 일관성을 보장한다
- 더 과거에 발생한 이벤트일수록 모든 노드에 전파됐을 확률이 높다

### 오버레이 네트워크

- 가십 프로토콜은 중요하고 유용하지만 적용 가능한 문제가 다양하지는 않다
- 비유행성(non-epidemic) 프로토콜을 사용하면 메시지 중복성을 낮추고 비확률적이고, 좀 더 최적의 방법으로 메시지를 전파할 수 있다


- 가십 프로토콜은 확장성이 높고, `log N` 번의 라운드 내에 메시지를 전파할 수 있지만 중복 메시지 수를 반드시 고려해야 한다
- 가십 기반 프로토콜에서 신뢰성을 보장하기 위해서 메시지 중복은 불가피하다


- 임의의 노드를 선택하면 시스템의 강건성(robustness)을 높일 수 있다
- 네트워크 파티션이 발생해도 결국 메시지는 전달된다
- 하지만 이를 위해선 불필요한 연결을 유지하고, 메시지를 중복 전송해야 한다


- 임의의 노드를 선택하는 대신 가십 시스템 내에 임시로 고정된 토폴로지를 정의하는 방법도 있다
- 주변 노드를 샘플링하고, 근접성을 기반으로 최적의 노드를 선택해 오버레이 네트워크(overlay network)를 구성한다


- 시스템의 토폴로지는 스패닝 트리를 사용해 표현할 수 있다


- 하지만 이 방식의 단점은 서로에 대한 선호도가 높은 여러 노드로 구성된 집단이 형성될 수 있다는 점이다


- 시스템이 안정적일 때는 고정된 토폴로지와 트리 기반 브로드캐스팅 방식을 사용하고, 장애 조치 및 복구 시에는 가십 프로토콜을 사용하면 신속하게 복구하고 메시지 중복을 줄일 수 있다

### 혼합형 가십 프로토콜

- 플럼트리(Plumtree, Push/lazy-push multicast tree)는 가십 기반 전파 방식과 트리 기반 브로드캐스트 방식을 모두 사용하는 혼합형 가십 프로토콜이다


- 플럼트리는 스패닝 트리 오버레이를 구성하고, 최소한의 오버헤드로 노드에 메시지를 전파한다
- 노드는 피어 샘플링 서비스(peer sampling service)가 지정한 소규모 노드 집단에 메시지를 전달한다


- 집단의 구성원에게는 메시지를 전달하고, 나머지에게는 게으르게 메시지 ID를 전달한다
- 메시지 ID를 전달받은 노드는 주변 노드에 질의해 메시지를 가져온다
- 이를 lazy-push라고 한다
    - 덕분에 높은 신뢰성을 보장하고, 신속하게 브로드캐스트 트리를 복구할 수 있다


- 사용량이 일정한 네트워크에서 레이지-푸시 메커니즘을 사용해 트리를 구성 및 재구성하면 가장 먼저 응답하는 노드가 브로드캐스트 트리에 추가되기 때문에 메시지 레이턴시를 최소화할 수 있다

https://github.com/helium/plumtree

### 부분 뷰

- 모든 노드에 메시지를 브로드캐스트하면 비효율적이고 비용이 매우 높다
- 노드의 이탈률(churn) (노드의 추가 및 이탈 횟수를 나타내는 수치)가 높은 경우 더 비효율적이다


- 이를 해결하기 위해 가십 프로토콜은 피어 샘플링 서비스를 사용한다
- 시스템의 부분 뷰(partial view)를 가십을 통해 주기적으로 갱신 및 유지한다


- 혼합형 부분 뷰(HyParView, Hybrid Partial View)은 각 노드별로 클러스터의 작은 액티브 뷰와 큰 패시브 뷰를 유지한다
- 액티브 뷰는 메시지 전파를 위한 오버레이를 구성하며, 패시브 뷰는 액티브 뷰에서 장애가 발생한 노드를 대체할 노드의 목록을 사용한다


- 노드는 주기적으로 액티브 뷰, 패시브 뷰를 서로 교환하는데 이 과정에서 각 노드는 자신의 패시브 뷰에 전달받은 액티브 뷰와 패시브 뷰의 노드를 추가한다
    - 목록 크기 제한을 위해 오래된 노드는 제거한다


- 이 방식은 액티브 뷰의 노드에만 메시지를 전파하므로 메시지 수가 감소하고, 패시브 뷰를 복구 용도로 사용해 높은 신뢰성을 보장할 수 있다


- 토폴로지 재구성 시 피어 샘플링 서비스가 얼마나 빨리 안정적인 오버레이로 수렴할 수 있는지가 알고리즘의 성능과 품질을 결정하는 척도 중 하나다
- HyParView는 뷰를 유지하는 방식과 새로운 프로세스에 우선권을 주는 점 때문에 성능과 품질이 높은 편이다


- HyParView나 플럼트리는 글로벌 뷰에 의존하지 않는다
- 이는 노드가 많으면 비효율적이고, 전체 노드 목록을 유지하는 비용이 높다
- 부분 뷰를 사용하면 각 노드는 인접 노드와만 통신하면 된다

https://www.bartoszsypytkowski.com/hyparview/

## 요약

