# Chapter 7
불변 스토리지에서 저장된 파일은 수정할 수 없다. 한 번 작성된 테이블은 다시는 수정할 수 없다.

B- 트리를 가변 자료 구조의 대표적인 예, LSM은 append only + merge reconciliation(병합 조정)을 기반으로 한 불변 자료 구조의 대표적인 예

인플레이스 업데이트를 지원하는 자료구조는 읽기 작업에 효율적, append only는 쓰기 작업에 유리.

가변 B-트리 구조와 구성 방식 때문에 쓰기 및 유지보수 작업의 I/O는 랜덤 I/O다. 모든 쓰기 작업은 데이터가 저장된 페이지를 찾은 뒤에 업데이트할 수 있다.

## LSM Tree

B-트리 메모리 공간 문제, 쓰기 증폭 문제 -> 버퍼링을 통해 해결.

버퍼링을 적용하는 방법
1. 변경 사항을 디스크 페이지에 적용하는 시점을 늦추는 방식
2. 쓰기 작업을 순차적으로 수행하는 방식

LSM Tree : 버퍼링 + append only를 통해 순차 쓰기를 지원한다.

LSM 트리는 데이터 파일 쓰기를 지연시키고 변경 사항을 메모리 기반 테이블에 저장하며, 나중에 내용을 불변 디스크 파일에 저장해 변경 사항을 반영한다.

불변 파일은 순차 읽기에 적합한 구조이다. 데이터를 디스크에 싱글 패스로 저장할 수 있고 파일은 append only다.

불변 파일은 데이터를 연속된 공간에 저장해 단편화를 방지한다. + 추가될 데이터를 위한 공간 등을 비롯해 공간 할당을 미리 하지 않아도 되기 때문에 밀도가 높다. 또한 삽입과, 수정 삭제 작업은 디스크에서 레코드를 찾지 않아도 된다. 대신 중복 저장을 허용하고 충돌은 읽기 중에 해결한다.

LSM 트리에서는 읽기 작업이 최대한 적은 수의 파일을 읽도록 파일을 병합하고 재작성 해야한다.

## LSM Tree 구조

디스크에 불변하는 파일 내용을 쓰려면 먼저 그 내용을 메모리 버퍼에 저장하고 정렬해야 한다.

메모리 기반 컴포넌트 즉, memtable은 불변 자료 구조로 데이터 레코드를 버퍼에 저장하고 읽기와 쓰기 작업을 적용한다.

memtable 업데이트는 디스크에 접근하지 않기 때문에 디스크 I/O가 발생하지 않으며, 선행 기록 로그 파일을 따로 유지해 레코드의 지속성을 보장한다.

7장의 테이블 : 디스크 기반 테이블

### 이중 컴포넌트 LSM 트리

이중 컴포넌트 LSM 트리는 불변 세그먼트로 구성된 단일 디스크 기반 컴포넌트(100% 채워진 노드와 읽기 전용 페이지로 구성된 B-트리)가 있다.

메모리 기반 트리에 저장된 데이터는 여러 파트로 나눠서 디스크로 플러시된다.

플러시 과정에서 플러시된 인메모리 서브트리별로 디스크에서 해당 서브트리를 찾아 두 세그먼트를 병합하고 디스크의 새로운 세그먼트에 저장한다.

병합 작업은 디스크 기반 리프 노드와 인메모리 트리 노드를 반복자를 통해 순회하면서 순서대로 값을 비교한다. (두 트리가 모두 정렬됐기 때문)

서브트리 병합과 플러시 구현 시 기억해야 할 사항
1. 플러시 과정이 시작되는 즉시, 그 이후의 모든 새로운 쓰기 요청은 새로운 memtable에 저장해야 한다.
2. 서브트리 플러시 과정을 진행하는 중에도 읽기 작업은 디스크와 인메모리 서브트리에 접근할 수 있어야 한다.
3. 플러시가 완료되면 병합된 트리를 접근 가능한 상태로 만드는 작업과 병합되지 않은 디스크 및 인메모리 데이터 삭제 작업을 원자적으로 수행해야 한다.

이중 컴포넌트 LSM 트리는 인덱스 파일에 적합한 자료 구조이지만 잦은 병합 작업이 쓰기 증폭을 유발하기 때문에 저자가 알고 있는 사용 사례가 없다.

### 다중 컴포넌트 LSM 트리

두 개 이상의 디스크 기반 테이블이 있는 다중 컴포넌트 LSM 트리의 구조를 살펴보자.

이 구조는 memtable 전체를 한 번에 플러시한다.

여러 위치에서 데이터를 읽는 것은 비용이 많이 들기 때문에, compaction이라는 주기적 병합을 한다.

### 인메모리 테이블

새로운 memtable을 할당해 그 이후에 들어오는 쓰기 작업을 담당하게 하고, 새로운 테이블은 플러시 상태로 전환한다. 이 과정은 원자적으로 수행되어야 한다.

데이터는 이미 메모리에 정렬되어 있기 때문에 이들을 순차적으로 디스크에 쓰면 디스크 기반 테이블이 만들어진다.

memtable이 완전히 플러시 되기 전까지 해당 내용이 유일하게 디스크에 저장된 곳은 WAL이다. (플러시 되면, 로그에서 삭제한다.)

### 수정과 삭제

LSM 트리는 삽입, 수정, 삭제 시 디스크에서 데이터를 찾을 필요가 없고, 대신 읽기 중에 중복 데이터는 조정한다.

단순히 memtable에서만 데이터를 삭제한다면 삭제 작업은 아무런 영향이 없거나 이전 값을 부활시킬 뿐이다.

따라서 삭제 내역을 명시적으로 기록하기 위해, 해당 키의 값이 삭제됐음을 나타내는 특수한 삭제 항목(tombstone)을 삽입한다.

특정 키가 아니라 연속된 키 범위를 삭제하는 방법이 더 효율적인 경우도 있다. (range tombstone)

### 병합-반복

디스크 테이블은 정렬되어 있기 때문에 multiway merge sort를 할 수 있다. (feat. priority queue)

각 헤드 원소를 우선순위 큐에 삽입하고 큐의 원소를 결과 반복자에 반환하여 최종 결과는 정렬된 상태를 만든다.

반복자 병합 방법
1. 반복자의 헤드 원소로 큐를 채운다.
2. 큐에서 가장 작은 값(헤드)를 선택한다.
3. 해당 반복자에 원소가 남아있을 경우 다음 원소를 큐에 추가한다.

### 조정

같은 키에 대한 여러 값 사이의 충돌 해결 및 조정 단계도 중요하다.

여러 데이터 레코드를 조정하려면 어떤 값이 우선하는지 알아야 하며, 타임스탬프를 비교해서 순서를 정할 수 있다.

### LSM 트리 유지보수

LSM 트리는 주기적인 컴팩션을 통해 꾸준히 증가하는 디스크 테이블의 수를 줄인다.

컴팩트 대상 테이블은 컴팩션이 끝날 때까지 읽을 수 있는 상태를 유지해야 하며, 디스크에 컴팩션된 테이블을 쓸 수 있을만큼의 공간이 확보되어야 한다.

동시에 여러 컴팩션이 수행될 수는 있으나, 작업의 대상 테이블이 겹치지 않는다.

컴팩션 과정에서 툼스톤을 바로 삭제하지는 않고, 더 작은 타임스탬프가 설정된 동일한 키의 레코드가 존재하지 않는 것을 확인한다.

### 레벨형 컴팩션

디스크 레이블을 여러 레벨로 나누고, 각 레벨의 테이블 크기는 제한되며 각 레벨을 나타내는 인덱스 번호가 있다.

memtable을 플러시하면 0번 레벨 테이블이 생성된다.

컴팩션시 같은 레벨의 파티션을 파티션하고 병합한다.

이전 2개의 레벨에서 범위가 겹치는 테이블을 합쳐 다음 레벨에 새로운 테이블을 생성한다.

### 크기 단계별 컴팩션(size-tiered)

레벨이 아닌 테이블의 크기를 기준으로 디스크 테이블을 그룹화한다.

문졔 : table starvation(컴팩션된 테이블의 크기가 여전히 작으면 높은 인덱스 레벨 테이블은 컴팩션 기회를 얻지 못해 툼스톤이 정리되지 않고, 읽기 비용이 증가하게 됨)

## 읽기, 쓰기, 메모리 공간 증폭

중복된 데이터가 차지하는 공간을 회수하면 공간 오버헤드를 줄일 수 있으나, 연속된 테이블 재작성으로 인해 쓰기 증폭이 생기고,

반대로 데이터를 연속적으로 쓰지 않으면 읽기 증폭(읽기 중에 같은 키의 레코드를 조정)과 공간 증폭(중복 레코드가 더 오랜시간동안 유지)이 생긴다.

***참고***

B-트리는 writeback, 같은 노드를 연속 업데이트할 때 쓰기 증폭 발생

LSM트리는 컴팩션 중 파일 간 데이터 복사할 때 쓰기 증폭 발생

### RUM(Read, Update, Memory) 예측

스토리지 자료 구조의 비용 모델이며, 세 가지 오버헤드 중 두 개를 줄이면 나머지 오버헤드가 불가피하게 증가한다는 것이다.

RUM은 레이턴시, 접근 패턴, 구현 복잡도, 유지보수 오버헤드, 하드웨어 관련 문제 등을 고려하지 않지만 일차적으로 비용을 어림잡는 규칙으로 쓸 수 있다.

## 세부 구현 설명

메모리와 디스크 기반 테이블 구현 방식과 세컨더리 인덱스의 원리, 읽기 시 참조하는 디스크 테이블을 줄이는 방법 등을 알아보자

### SS Table(Sorted String Table)

레코드를 키 순서로 정렬해 저장하며, 인덱스 파일과 데이터 파이로 구성된다.

인덱스 파일은 B-트리 등의 로그 시간 룩업이 가능한 자료구조 또는 Hash Table 등의 constant-time 룩업기 가능한 자료 구조를 사용한다.

데이터 파일은 레코드를 키순서로 젖아하기 때문에 해시 테이블을 사용해 인덱싱해도 범위 스캔을 쉽게 구현할 수 있다.

데이터 레코드가 정렬되어 있으므로 컴팩션 시에는 인덱스 컴포넌트에 접근하지 않고 데이터 파일을 순차적으로 읽으면 된다.

컴팩션 작업의 병합 대상 테이블의 순서는 같기 때문에 병합-반복의 결과도 순서가 보장된다.

***SSTable-Attached Secondary Index***

LSM 트리는 데이터를 버퍼에 저장하기 때문에 인덱스는 메모리와 디스크 기반 테이블을 모두 인덱싱해야 하며, 이를 위해 SASI는 memtable을 인덱싱하는 인메모리 자료 구조를 별도로 생성한다.

SSTable의 수명주기와 동기화하기 떄문에 멤테이블 플러시 또는 컴팩션 중에 인덱스를 생성할 수 있다.

### Bloom filter

LSM 트리의 읽기 증폭은 읽기 작업이 여러 디스크에 저장된 테이블에 접근할 떄 발생한다.

테이블 룩업을 방지하기 위해 메타데이터에 키 범위를 저장하고 검색 키가 범위에 속하는지 미리 확인할 수 있따.

따라서 확률적 자료구조인 bloom filter를 이용한다. (참고로 보통 자료구조보다 공간 효율적)

집합에 속하지 않지만 속한다고 잘못 판단하는 false-positive는 발생하지만, false-negative는 발생하지 않는다.

### Skiplist

데이터를 메모리에 정렬해서 저장하는 여러 자료 구조가 있다.

스킵리스트는 싱글 링크드 리스트보다 구현이 그리 복잡하지 않으며, 확률적 복잡도도 탐색 트리와 비슷한 수준이다.

삽입과 업데이트 시 구조를 회전 또는 재배치하지 않고 확률적으로 균형을 유지하며, 따라서 인메모리 B- Tree보다 캐시 친화적이지 않다. (스킵리스트의 노드 크기는 작고 임의의 메모리 공간에 할당되기 때문이며, unrolled linked list를 사용해 해결할 수 있다.)

높이가 다른 여러 노드로 구성되며 연결한 계층 구조를 통해 일부 요소를 건너뛸 수도 있다.

노드의 높이는 삽입 시 임의의 함수를 통해 결정되며, 높이가 같은 노드는 레벨을 형성한다.

레벨의 수는 제한되어 있으며, 최대 원소 수를 기준으로 최대 높이를 결정한다. 레벨이 높아질수록 노드의 수가 급격히 줄어든다.

탐색은 최상위 레벨 포인터에서 시작해서 다음 레벨 혹은 다음 노드로 움직이며 찾는다.

삽입 단계도 마찬가지로 탐색을 통해 삽입 지점을 찾고 해당 지점에 새 노드를 삽입한다.

Usage : 아파치 카산드라는 세컨더리 인덱스 memtable 구현에, WiredTiger는 일부 인메모리 작업에 사용한다.

### 디스크 접근

많은 LSM 트리 구현이 디스크 접근과 중간 캐싱에 페이지 캐시를 사용한다.

페이지 만료, 고정 등 다양한 기법을 Log-Strucuctured 스토리지에 똑같이 적용할 수 있으며, 인메모리 데이터는 수정할 수 없기 때문에 동시 접근에 잠금 및 래치가 필요 없다.

LSM 트리의 데이터 레코드는 페이지와 align되지 않아, 페이지 경계를 넘나들며 메모리에서 여러 페이지를 읽어야 할 수 있다.

### 압축

B- 트리 데이터 압축과 유사하며, 데이터를 페이지 단위로 압축하면 압축된 페이지는 압축되지 않은 페이지보다 크기가 작기 때문에 페이지와 align되지 않는다.

압축된 페이지의 오프셋과 크기를 저장하는 간접 레이어를 통해 압축된 페이지에 접근할 수 있다.

## 비정렬 LSM 스토리지

순서를 보장하지 않는 스토어는 일반적으로 별도의 로그가 필요 없고 레코드를 삽입 순서대로 저장하기 떄문에 쓰기 비용이 줄어든다.

### Bitcask (feat. Riak)

memtable을 버퍼로 사용하지 않고 데이터 레코드를 로그 파일에 바로 저장한다.

레코드 검색을 위해 각 키의 최신 데이터 레코드에 대한 참조를 keydir이라는 자료 구조에 저장하며, 참조하지 않는 이전 데이터 레코드들이 여전히 디스크에 남아있다면 컴팩션시 GC가 정리한다.

keydir은 in-memory hashmap 형태이며 시스템 가동 시 로그 파일을 이용해 재구성한다.

- 쓰기 요청 시 : 로그 파일에 순차 추가, 포인터를 keydir에 추가
- 읽기 요청 시 : keyidr에서 해당 키를 찾고 로그 파일을 가리키는 포인터를 따라감.

WAL이 없어 공간 오버헤드와 쓰기 증폭이 줄어들지만, 범위 스캔이 불가능하고 포인트 쿼리만 수행할 수 있다.

### 위스키(WiscKey)

LSM 트리에 키를 정렬된 상태로 유지하고 vLog(value log)라는 정렬되지 않은 append-only 파일에 데이터 레코드를 저장해 GC와 Sort 작업을 분리한다.

vLog 파일에는 데이터 레코드를 임의의 순서로 저장하고, Sorted LSM Tree에는 로그 파일에 저장된 최신 레코드를 가리키는 키를 저장한다.

키는 데이터 레코드보다 크기가 훨씬 작기 때문에 컴팩션 시 효율이 매우 높으며, WiscKey는 업데이트 및 삭제 빈도가 낮아 GC가 회수해야 하는 디스크 공간이 크지 않은 환경에 적합하다.

(16년도 논문인데, 딱히 검색해봐도 관련된 DB가 나오지는 않는 듯)

## LSM 트리 동시성 제어

- 테이블 뷰 전환 : 플러시 및 컴팩션으로 변경되는 메모리와 디스크 기반 테이블
- 로그 동기화

일반적인 동기화 단계
- memtable 전환
- 플러시 완료
- WAL 삭제

## Log Stacking

SSD도 소규모의 랜덤 쓰기 처리, 쓰기 오버헤드 최소화, 웨어 레벨링 개선, 기기 수명 연장을 위해 Log-Stuctured Storage(이하 LSS)를 사용한다.

**웨어 레벨링(wear leveling) :** 모든 블록에 데이터를 분산해 쓰도록 하여, 특정 블록이 열화하면 데이터 소실이나 고장을 막는 방법

### 플래시 변환 계층

SSD는 이전 데이터가 삭제된(erased) 페이지에만 새로운 데이터를 쓸 수 있다.

Flash Traslation Layer(FTL)은 논리적 페이지 주소를 물리적 위치로 변환하고 페이지의 상태를 관리한다. 사용 가능 페이지가 부족하면 FTL은 GC를 수행하고 삭제된 페이지를 정리한다.

### 파일 시스템 로깅

대부분의 파일 시스템은 쓰기 증폭을 줄이고자 수정 내용을 버퍼에 저장하는 것에 로깅 기법을 사용하고 기반 하드웨어를 최대한 활용한다.

상위 레벨(e.g. 애플리케이션) 로그를 삭제하면 하위 레벨(e.g. 파일 시스템) 로그에서 단편화가 발생할 수 있다.

이런 상황에서 중요한 것은 파티션과 하드웨어가 align되고 레코드도 페이지 사이즈와 align되도록 하는 것이 더 중요하다.

## LLAMA와 투명한 Stacking

LLAMA : latch-free, log-structured, access-method-aware (무잠금, 로그 구조의, 접근 방식이 투명한)

### Open-Channel SSD

소프트웨어 계층 스태킹의 대안으로 간접 레이어를 건너뛰고 하드웨어에 바로 접근하는 방법이 있다. 

Open Channel SSD는 로그 계층이 줄기 때문에 wear leveling, GC, 데이터 배치, 스케줄링을 더 세밀하게 할 수 있다. (FTL을 거치지 않고 접근 가능)

Usage : LOCS, LightNVM (at linux kernel)