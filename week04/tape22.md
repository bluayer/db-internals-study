# 7장 로그 구조 스토리지


불변 스토리지에서도 저장된 파일, 한 번 작성된 테이블은 다시 수정할 수 없다. 회계사처럼 새 레코드는 새로운 파일에 추가한다. <br>
반면 가변 스토리지는 디스크에 저장된 레코드를 바로 수정한다.

이처럼 LSM 트리는 불변 자료구조로, append-only 이며 병합 조정 방식을 사용하고, <br>
-> 쓰기만 하면 되니까 write 유리하다. <br>
-> 쌓인 여러 레코드 버전을 읽고 데이터를 조정해야하기 때문에 read 성능이 떨어진다.

<br>

B-TREE는 가변 자료구조로, 디스크에서 레코드를 찾고 해당 page의 기존 오프셋 위치에 update를 한다. <br>
-> update를 하려고 대상을 디스크에서 찾기 때문에 write 성능이 떨어진다.<br>
-> 다만 여러 버전을 비교할 필요없이 바로 값을 읽으면 되기 때문에 read 작업이 효율적이다.

----

## LSM 트리

LSM 트리는 버퍼링과 append-only 구조로 순차 쓰기(큰 용량 파일 저장할때 속도)를 지원한다.
또한 변경사항을 메모리 기반 테이블에 저장하고, 나중에 해당 내용을 불변 디스크 파일에 저장하여 변경사항을 반영한다. (쓰기 지연)


### 트리 구조

작은 메모리 기반 컴포넌트(memtable)와 큰 디스크 기반 컴포넌트로 구성된다. 불변 파일을 쓰려면 일단 메모리 버퍼에 내용을 저장하고, 정렬한다.

- 불변 자료구조인 memtable은 레코드를 버퍼에 저장하고, 읽기/쓰기 작업에 적용한다.
    - memtable 저장된 데이터 크기가 특정 기준 값을 넘으면, 해당 내용을 디스크에 복사하게 된다.
    - 레코드를 로그에 추가하고, 메모리를 커밋한 다음 작업 결과를 클라이언트에게 반환한다.


- 버퍼링은 메모리에 상주하는 테이블에만 적용된다.
    - 동시접근을 지원하는 정렬된 자료구조 형태를 유지한다.
    - 버퍼에 저장된 데이터는 디스크 기반 컴포넌트로 플러시한다. (플러시 전까지는 WAL에 저장한다.)

디스크 기반 컴포넌트는 읽기 작업에만 사용되며, 영구 저장된 데이터는 수정할 수 없다.

(1) 이중 컴포넌트 LSM 트리 : 한 개의 디스크 기반 컴포넌트가 있으면서, B-TREE

1개는 디스크, 1개는 메모리에 위치 <br>
플러시 할 때는 인메모리 서브트리 별로 찾은 서브트리를 병합하고, 디스크의 새 세그먼트에 저장한다. <br>
memtable 플러시로 인해 잦은 병합 작업이 쓰기 증폭을 유발해서 거의 사용되지 않는다. <br>


(2) 다중 컴포넌트 LSM 트리 : 두 개 이상의 디스크 기반 컴포넌트

memtable 전체를 한꺼번에 플러시한다. <br>
플러시가 발생할 수록 디스크에 테이블이 여러개 생성되고 <br>
테이블이 너무 많아지면, 여러 테이블 내용을 읽고 병합한 다음 새 파일에 결과를 저장하는 컴팩션을 주기적으로 수행한다. <br>


(3) 인메모리 테이블

- memtable을 플러시하려면
    - 새 멤테이블을 할당한다.
    - 이후에 들어오는 쓰기 작업들은 새 멤테이블이 담당한다. (읽기와 쓰기)
    - 기존 테이블은 flush 상태로 전환한다. (읽기)
    - flush 대상이 되는 테이블은 완전 플러시 될때까지 접근 가능해야한다.

완료되면 기존 멤테이블은 삭제되고, 디스크 기반 테이블에서 해당 내용을 읽을 수 있다.

데이터는 이미 메모리에 정렬되어있기 때문에, 순차적으로 디스크에 써주기만 하면 된다.

<br>

### 수정과 삭제

동일한 키에 대한 데이터가 중복 저장되어있을 수 있어서, 삭제할 때는 단순 레코드 삭제로 충분하지 않다.
그래서 삭제하고 나면 해당 키가 삭제되었음을 알 수 있도록 특수한 값을 삽입한다. (툼스톤?)

레코드 정렬 규칙을 유지하면서 연속된 키 범위를 삭제하는 predicate delete 방법도 있다.
범위 툼스톤은 특정 키 하나 값이 아니라 범위를 커버한다.


- 병합/반복

트리 룩업 단계에서는 여러 컴포넌트에 접근하기 때문에 병합 과정을 거쳐 결과를 반환한다.
디스크 테이블은 정렬된 상태이기 때문에 merge sort를 사용할 수 있다.

파일을 순회하는 커서가 있고, 이 커서는 마지막으로 참조된 데이터 레코드의 오프셋을 가진다.

1. 커서의 헤드 원소로 큐를 채운다.
2. 큐에서 가장 작은 값을 선택하여 결과에 추가한다.
3. 해당 커서의 다음 원소를 큐에 추가해서 반복한다.


### 조정

같은 키의 중복된 데이터가 충돌하면 어떻게 해결하는지도 중요하다.
각 레코드에는 타임스탬프가 메타데이터로 저장되어있어, 레코드 사이의 순서를 정하고 가장 최근 데이터를 알아낼 수 있다.
최신이 아닌 레코드들은 클라이언트에 반환하지 않고, 컴팩션 작업에도 제외한다.

<br>

### LSM 트리 유지보수 : 주기적인 컴팩션으로 증가하는 디스크 테이블 수를 줄인다.

컴팩션 대상은 끝날때까지 읽을 수 있는 상태를 유지하기 때문에, 디스크는 컴팩트 된 테이블을 쓸 수 있을만큼의 공간을 미리 확보해야한다.

-  레벨형 : RocksDB가 사용하는 방식
    - 디스크 테이블을 인덱스 번호가 있는 레벨로 나눈다.
    - memtable을 플러시하면 0번 레벨 테이블이 생성되고,
    - 0번 테이블 수가 일정 이상 벗어나면 1번 테이블을 생성한다.


-  크기 단계별 : 테이블 크기 기준으로 그룹화
    - 작고 큰 테이블로 나눠서 비슷한 크기끼리 그룹화한다.
    - 0번 레벨은 가장 작은 크기의 테이블이다.
    - 컴팩션으로 병합된 테이블은 같은 크기의 테이블이 저장된 레벨로 저장된다.
      (예: 아파치 카산드라 time window)

<br>

## 읽기, 쓰기, 메모리 공간 증폭

디스크에 불변방식으로 데이터를 저장할때는 다음과 같은 문제가 발생한다.

- 읽기 증폭 : 데이터를 읽기 위해 여러 테이블을 참조하며 발생
- 쓰기 증폭 : 컴팩션하는 과정에서 연속된 재작성으로 인해 발생
- 공간 증폭 : 같은 키에 대해 여러 레코드가 존재할 때 발생

** RUM 예측 => 스토리지 자료구조 비용모델

<br>

## 세부구현 설명

### 1. SSTable

레코드 키 순서로 정렬하여 저장 <br>
보통 디스크 기반 테이블은 Sorted String Table 로 구현되며, SSTable은 인덱스 파일과 데이터 파일로 구성된다.

- 레코드를 키 순서대로 저장하기 때문에, 범위 스캔에 용이하다.
- 데이터 레코드가 정렬되어있어 컴팩션 시에는 데이터 파일을 순차적으로 읽기만 하면 된다.


### 2. Bloom Filter

LSM 트리는 디스크 기반 테이블에 검색 키에 대한 레코드가 존재하는지 미리 알 수 없으므로, 데이터를 읽기 위해 여러 테이블을 참조해야한다. 그래서 읽기 증폭이 발생한다.

블룸 필터는 어떤 원소가 집합에 속하는지 여부를 확인할 수 있는 확률적 자료구조로, <br>
특정 키가 테이블에 존재할 수 있는지, 확실하게 존재하지 않는지를 알 수 있다.

- 데이터가 없지만 있다고 나올 수는 있지만,
- 데이터가 있는데 없다고 나오지는 않는다. 즉, 데이터가 없다고 나오면 정말 없는 값이다.

블룸필터는 레코드 키를 해시함수를 사용해서 해싱하고, 비트를 1로 설정한다. <br>
모든 해시함수의 결과들의 비트 값이 1이면 집합에 속한다고 판단하는데, 이는 일부 해시함수가 일부 키에 해당 비트위치를 할당했다는 것을 의미한다. (해시충돌이 발생할 수 있음.)

https://steemit.com/kr-dev/@heejin/bloom-filter
https://llimllib.github.io/bloomfilter-tutorial/

### 3. Skip List

(RocksDB, LevelDB) memtable

스킵 리스트는 삽입/업데이트 시 구조를 재배치하지 않고 확률적으로 균형을 유지한다.
높이가 다른 노드로 구성되며, 높이가 h인 노드는 한 개 이상의 높이가 최대 h인 이전노드와 연결된다.


### 4. 디스크 접근

- 테이블 내의 데이터는 대부분 디스크에 저장되기 때문에 블록 단위로 제공한다.
- LSM 트리의 데이터 레코드는 페이지와 얼라인되지 않을 수 있다.
- 포인터는 절대 오프셋을 사용해 구현할 수 있다.


### 5. 압축

- LSM 테이블은 불변 자료구조이며, 싱글패스로 저장한다. 데이터를 페이지 단위로 압축하면 크기가 작아지기 때문에 페이지와 얼라인 되지 않는다.
- 압축된 페이지에 접근하려면 데이터 주소범위를 기록해두어야한다.
- 컴팩션이나 플러시 시에는 압축된 페이지를 순차적으로 추가하고, 페이지가 요청되면 오프셋과 크기를 참조해 해제하고 메모리에 실체화하는 방식이다.

## 비정렬 LSM 스토리지

지금까지 설명한 대부분의 스토리지 자료는 정렬된 상태로 저장한다.

> B-TREE 페이지 : 인플레이스 업데이트 방식
> SSTable : 데이터 레코드를 메모리에 저장 및 정렬

비정렬은 데이터를 임의의 순서로 저장하기 떄문에, 별도 로그가 필요없고 쓰기 비용이 줄어든다.

- 비트캐스크
    - 리악에서 사용하는 스토리지 엔진 중 하나로, 데이터 레코드를 로그파일에 바로 저장한다.
    - 레코드 검색 시에는 최신 데이터 레코드 참조를 인메모리 해시맵 형태의 keydir 자료구조에 저장하고, 이전 데이터는 컴팩션 시 정리된다.
    - 읽기 요청 시에는 해당 키를 찾고 -> 로그 파일 포인터를 따라가면 된다. (key: value 는 1:1)
    - 컴팩션 시에는 모든 로그파일을 읽고 병합한 다음 새 위치에 쓴다.
    - 포인트 쿼리 성능에는 장점이나, 범위 스캔이 불가능하다.

<br>

- 위스키
    - LSM 트리에 키를 정렬된 상태로 유지하되, vLog라는 정렬되지 않은 append-only 파일에 데이터 레코드를 저장한다.
    - 정렬된 LSM 트리에는 최신 레코드를 가리키는 키를 저장
    - vLog는 정렬되지 않아서 범위 스캔 시에는 랜덤 I/O가 발생
    - 컴팩션 시에는 vLog를 순차적으로 읽고 병합한 뒤 새 위치에 쓴다. 포인터는 새로운 위치에 가리키도록 업데이트한다.

## LSM 트리 동시성 제어

LSM 트리의 가장 큰 동시성 문제는 테이블 뷰 전환, 로그 동기화이다. <br>
플러시 작업은 다음 규칙을 따른다.

- 새 memtable은 읽기 및 쓰기가 가능해야한다.
- 기존 멤테이블은 읽을 수 있어야한다.
- 플러시 대상 멤테이블은 디스크에 저장된다.
- 플러시된 멤타이블 삭제, 디스크 기반 테이블 생성은 원자적으로 수행되어야한다.
- 멤테이블이 플러시되면 선행기록 로그 세그먼트는 삭제된다.


<br>

동기화 과정은 다음과 같다.

- 멤테이블을 전환하고, 이후에는 새 멤테이블이 쓰기요청을 처리하는 기본 멤테이블이 된다.
- 플러시가 완료되면 기존 멤테이블은 플러시된 디스크 기반 테이블로 대체한다.
- 플러시된 멤테이블과 관련된 로그가 기록된 로그세그먼트를 삭제한다.


## 로그 스태킹

- 플래시 변환 계층

> SSD는 이전 데이터가 삭제된 페이지에만 새 데이터를 쓸 수 있는데, 페이지는 개별로 ㅅ가제할 수 없고 블록 단위로만 삭제할 수 있다. FTL은 논리적 페이지 주소를 물리적 위치로 변환하고 상태를 관리한다.

SSD에서 로그 구조 스토리지를 사용하는 이유는, 소규모 랜덤쓰기를 일괄 처리해서 I/O 비용을 낮추기 위해서다.

- 파일 시스템 로깅

대부분의 파일 시스템은 쓰기 증폭을 줄이고자 수정 내용을 버퍼에 저장하는데, 이 때 로깅 기법을 사용한다. <br>
계층 간에는 LSS 스케줄링을 공유하지 않기 떄문에, 일부 하위 레벨 서브시스템이 삭제되거나 불필요한 작업이 발생할수는 있다.


## LLAMA와 투명한 스태킹



- 오픈 채널 SSD



https://jaeyeong951.medium.com/색인-index-의-두-가지-형태-lsm-트리-b-트리-7a4ab7887db5