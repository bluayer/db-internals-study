# Chpater 5. 트랜잭션 처리와 복구

DBMS에서 트랜잭션이란 하나의 논리적 작업 단위를 의미하며 여러 작업을 한 단계로 표현하는 방법이다. 

ACID
- Atomicity
- Consistency
- Isolation
- Durability

트랜잭션을 위한 컴포넌트
- Tx manager : 트랜잭션의 세부 단계 제어, 관리 및 스케줄링
- Lock Manager : 리소스에 대한 동시 접근 제어, 데이터 무결성
- Page cache : 영구 저장소와 스토리지 엔진 사이에서 중개
- 로그 매니저 : 동기화되지 않은 페이지 캐시의 내용이 손실되지 않도록 로그를 저장

## 버퍼 관리

데이터베이스 : 디스크 + RAM

다른 프로세스가 디스크에 저장된 같은 페이지를 변경하지 않았다면 메모리에 캐시된 페이지를 재사용 가능 -> Virtual Disk

가상 디스크 읽기 작업은 요청된 페이지가 메모리에 없을 경우에만 물리적 저장소에 접근 -> Page cache or buffer pool

아직 캐시되지 않은 페이지를 디스크에서 메모리로 복사하는 작업 : paging

아직 디스크로 플러시되지 않은 변경된 페이지 : dirty page

Page cache의 주요 기능
- 페이지 내용을 메모리에 캐시
- 디스크에 저장된 페이지에 대한 변경 사항을 함께 버퍼링하고 캐시된 페이지에 반영
- 캐시되지 않은 데이터가 요청된 경우 메모리에 공간이 충분하다면 페이징하고 캐시된 버전을 반환
- 캐시된 페이지가 요청된 경우 메모리에서 반환
- 메모리에 새로운 페이지를 추가할 공간이 없을 경우 일부 페이지를 만료, 페이지로 플러시

**O_DIRECT 플래그** : I/O 시스템 호출 시 커널 페이지 캐시를 우회하고 디스크에 바로 접근

### 캐싱

스토리지 엔진이 특정 페이지를 요청하면 우선 캐시된 버전이 있는지 확인하고 있으면 반환한다.

없다면 논리적 페이지 주소 혹은 페이지 번호를 물리적 주소로 변환해 해당 페이지를 메모리로 복사하고 반환한다.

페이지가 변경된 경우에는 페이지에 더티 플래그(디스크와 동기화되지 않았다는 플래그)를 설정한다.

### 캐시 만료

페이지가 동기화됐고 고정 또는 참조 상태가 아니라면 바로 제거될 수 있다. 페이지를 제거할 때마다 디스크로 플러시한다면 성능을 저하시킬 수 있다. 

따라서 일부 DB는 별도의 백그라운드 프로세스가 제거될 가능성이 높은 더티 페이지를 주기적으로 디스크로 플러시한다.

PGSQL의 backgroud flush writer가 이 역할을 한다.

데이터베이스에 장애가 발생하면 플러시되지 않은 데이터는 손실된다. 데이터 손실을 방지하기 위해 checkpoint 프로세스가 플러시 시점을 제어한다. checkpoint 프로세스는 WAL와 페이지 캐시의 싱크가 맞도록 조정한다.

캐싱의 trade-offs
- 디스크 접근 횟수를 줄이기 위해 플러시 시점을 늦춘다.
- 페이지르 우선적으로 플러시해 빠르게 캐시에서 제거한다.
- 제거할 페이지를 선택하고 최적의 순서로 플러시한다.
- 캐시 크기를 메모리 범위 내로 유지한다.
- 기본 저장소에 저장되지 않은 데이터는 손실되지 않아야 한다.


### 페이지 고정

가까운 시간 내에 요청될 확률이 높은 페이지는 고정시킬 수 있다.

페이지를 캐시에 가둬 두는 것을 고정(pinning)한다고 표현한다.

고정된 페이지는 메모리에 더 오랜 시간 동안 유지되기 때문에 디스크 접근 횟수가 줄어들고 성능에 도움이 된다.

상위 레벨 노드를 메모리에 고정시키고 나머지 노드는 요청 시 페이징해도 된다.

서브트리에 대해 수행된 작업으로 인해 병합과 분할이 연속해서 발생할 수 있다. 이런 변경 사항을 디스크에 바로 쓰는 대신 메모리에 모아뒀다가 일괄 적용하면 이와 같은 상황을 방지하고 디스크 접근 횟수와 작업 비용을 줄일 수 있다.

### 페이지 교체 알고리즘

캐시된 페이지가 요청될 확률을 계산할 수 있어야 하고, 캐시된 페이지는 eviction policy에 따라 캐시에서 제거된다.

캐시 용량을 늘리면 제거되는 페이지가 줄어들 것 같지만 그렇지 않다. 벨레이디의 모순 현상은 적합하지 않은 페이지 교체 알고리즘을 사용했을 때 페이지 수가 증가하면 제거되는 페이지 수도 증가하는 현상을 의미한다. 만료된 페이지가 다시 페이징되면 공간을 선점하기 위해 다른 페이지와 경쟁해야 한다.

- FIFO, LRU : LRU는 동시접근 환경에서 매우 비효율적일 수 있음(페이지 요청 때마다 참조&노드 갱신해야해서)
- CLOCK : LRU의 대안, 더 단순하고 캐시 친화적이며 동시성을 지원한다.
- LFU : 요청 빈도가 가장 낮은 페이지를 제거

## 복구

데이터베이스 개발자는 여러 장애 시나리오를 고려하고 "약속된" 데이터가 실제로 저장되게 해야 한다.

WAL은 장애 및 트랜잭션 복구를 위해 디스크에 저장하는 append-only 보조 자료구조다.

- 디스크에 저장된 페이지에 대한 변경 사항을 페이지 캐시에 버퍼링하는 동시에 DBMS 맥락에서의 지속성을 보장한다.
- 캐시된 페이지가 디스크와 동기화될 때까지 작업 이력을 디스크에 저장한다. 데이터베이스의 상태를 변경하는 모든 작업을 실제 페이지에 적용하기 전에 먼저 디스크에 로깅한다.
- 장애 발생 시 로그 기반으로 마지막 메모리 상태를 재구성한다.

WAL은 데이터가 영구 저장소에 저장되도록 보장하고 로그를 재수행해서 커밋되지 않은 트랜잭션을 완료하거나 장애가 발생하기 전의 상태로 되돌릴 수 있기 때문에 매우 중요하다.

**PostgreSQL vs fsync()** : fsync에서 I/O 에러가 발생하면 플러시되지 않은 페이지의 더티 플래그를 초기화하기 때문에 체크포인트 프로세스에서 데이터가 플러시되었다고 착각할 수 있음

### 로그의 시맨틱

WAL은 여러 로그 레코드로 구성되며 모든 레코드에는 단조 증가하는 Log Sequence Number(LSN)이 있음

로그 레코드는 디스크 블록보다 작을 수 있기 때문에 로그 버퍼에 임시 저장하고 force 작업 시 디스크로 플러시한다.

force는 로그 버퍼가 가득차면 수행되거나 트랜잭션 매니저 또는 페이지 캐시가 직접 요청할 수 있다.

WAL은 작업 로그 레코드 외에도 트랜잭션 완료 여부를 나타내는 레코드를 저장한다. 트랜잭션의 커밋 레코드의 LSN까지 플러시되기 전까지 해당 트랜잭션은 커밋된 것으로 간주할 수 없다.

일부 시스템 : Compensation Log Record(CLR)을 로그에 저장하고 undo 작업 시 사용

WAL은 체크포인트에 도달하면 이전 로그를 trimming하는 인터페이스를 통해 기본 저장소와 동기화한다.

체크 포인트는 해당 시점이 전의 모든 로그 레코드가 플러시됐고 더 이상 필요하지 않다는 것을 명시하는 수단. 또한 모든 더티페이지를 강제로 디스크로 플러시해 기본 저장소와 완전히 동기화하는 작업을 sync checkpoint라고 한다.

모든 데이터를 한 번에 디스크로 플러시하면 체크포인트 작업이 완료될 떄까지 모든 작업을 중지해야 하기 때문에 비효율적 -> fuzzy checkpoint를 사용

### 작업 로그 vs 데이터 로그

이전 상태에 redo 작업을 수행하면 이후 상태가 된다. 이후 상태에 undo 작업을 수행하면 이전 상태가 된다.

물리적 로그 또는 논리적 로그를 사용해 레코드와 페이지의 상태를 특정 상태에서 다른 상태로 되돌리거나 재구성할 수 있다.

undo 작업에는 "동시성과 성능을 위해" 논리적 로그를 사용하고 redo 작업에는 "복구 시간 단축을 위해" 물리적 로그를 사용한다.

Q. 물리적 로그를 쓰면 왜 시간이 단축될까? 해석없이 모든 상태를 실행하면 되기 때문인가?

### 스틸과 포스 정책

steal/no-steal 정책과 force/no-force 정책을 기반으로 메모리에 캐시된 변경 사항을 디스크로 플러시하는 시점을 결정한다.

Steal 정책은 트랜잭션이 수정한 페이지를 커밋하기도 전에 플러시하는 것을 허용한다. no-steal은 커밋되지 않은 트랜잭션이 디스크로 플러시되는 것을 허용하지 않는다.

더티 페이지를 steal한다는 것은 메모리에 캐시된 데이터를 디스크로 플러시하고 디스크에서 다른 페이지를 페이징하는 것을 의미한다.

force 정책은 트랜잭션이 수정한 모든 페이지를 커밋 전에 플러시한다. 반대로 no-force는 일부 페이지가 디스크로 플러시되지 않았더라도 트랜잭션 커밋을 허용한다.

더티 페이지를 force한다는 것은 커밋 전에 디스크로 플러시한다는 것을 의미한다.

undo는 포스된 페이지를 롤백하고, redo는 커밋된 트랜잭션을 다시 수행한다.

no-steal 정책 사용 : redo 로그만 사용해 상태를 복구할 수 있다. 

force 정책 사용 : 장애 복구 시 트랜잭션 커밋 결과를 재구성하지 않아도 되지만 많은 I/O로 인해 트랜잭션 커밋 시간이 증가한다.

### ARIES

ARIES는 steal/no-force 기반 복구 알고리즘이다.

빠른 복구를 위해 물리적 redo log를 사용하고, 일반 작업의 동시성을 높이기 위해 논리적 undo를 사용한다.

장애 발생 후 DBMS를 재시작하면 복구는 다음 3단계로 진행된다.

1. 분석(analysis) 단계 : 페이지 캐시에 저장된 더티 페이지와 장애 발생 당시 수행 중이던 트랜잭션을 파악하고, redo의 시작 단계를 결정한다.
2. redo : 장애 발생 전까지의 작업을 재수행
3. undo : 불안정한 트랜잭션을 롤백하고 데이터베이스를 마지막 일관된 상태로 복원. 복구 중에도 장애가 발생할 수 있기 떄문에 undo 작업도 로그에 기록한다.

## 동시성 제어

- Optimistic Concurrency  Control
- MVCC
- Pessimistic Concurrency Control

### 직렬화 가능성

DB의 관점에서 스케줄이란 트랜잭션을 수행하는 데 필요한 작업(읽기, 쓰기, 커밋, 중단 등의 데이터베이스 상태를 변경하는 작업)의 목록이다.

포함된 모든 트랜잭션이 교차하지 않고 완전히 독립적으로 수행될 수 있는 스캐줄을 serial 스케줄이라고 한다.

직렬 스케줄의 모든 트랜잭션은 다음 트랜잭션이 시작하기 전에 수행이 완료된다. 하지만 항상 트랜잭션을 하나씩 실행하면 시스템의 처리량이 크게 제한되고 성능이 저하된다.

Serializable 스케줄 : 동일한 트랜잭션 집합에 대한 완전한 직렬 스케줄 중에서 동일한 스케줄이 있을 경우, 해당 스케줄은 직렬화하 가능하다고 한다.

### 트랜잭션 격리

격리 수준은 트랜잭션이 변경한 내용 중 어떤 부분이 언제 다른 트랜잭션에서 접근할 수 있는지를 정의한다.

### 읽기와 쓰기 이상 현상

읽기 이상 현상
- Dirty Read
- Non-repeatable read
- Phantom read

쓰기 이상 현상
- lost update
- dirty write : dirty read 후 수정 및 커밋
- write skew : 불변 조건은 충족하지만 동시 수행 시 조건이 위반

### 격리 수준

- read uncommitted : dirty read 허용
- read committed : 팬텀 읽기, 반복 불가능 읽기 발생 가능
- repeatable read : 팬텀 읽기 가능
- 직렬화 가능

서로 의존성이 없는 트랜잭션은 완전히 독립적이기 떄문에 임의의 순서로 수행해도 된다.

분산 시스템 맥락에서의 선형화 가능성과 다르게 직렬화 가능성은 임의의 순서로 수행된 여러 작업에 대한 속성이다.

일부 데이터베이스는 snapshot isolation 수준을 지원한다. 각 트랜잭션은 시작 당시의 다른 트랜잭션이 커밋한 내용을 확인할 수 있다.

트랜잭션은 데이터의 스냅숏을 생성하고 이에 대해 쿼리하며 트랜잭션 수행 중에는 스냅숏을 변경할 수 없다.

두 개의 트랜잭션이 같은 값을 수정할 경우 한 개의 트랜잭션만이 커밋될 수 있다.

스냅숏 격리 수준에서도 쓰기 치우침이 발생할 수 있다.

### 낙관적 동시성 제어

트랜잭션 충돌이 거의 발생하지 않는다고 가정하고, 결과를 커밋하기 전에 트랜잭션을 검증해 동시 수행 트랜잭션의 읽기/쓰기 충돌을 방지하고 직렬화 가능성을 확인한다.

- 읽기 단계 : 트랜잭션은 자신이 변경한 내용을 다른 트랜잭션에서 볼 수 없도록 개별 컨텍스트에서 트랜잭션 단계를 수행한다.
- 검증 단계 : 충돌 발생 확인. 트랜잭션이 쿼리한 데이터가 최신이 아니거나 읽기 단계 중에 수정 및 커밋한 값을 다른 트랜잭션이 덮어쓴 경우 컨텍스트를 초기화하고 읽기부터 다시 수행한다. 트랜잭션 커밋시 ACID 속성이 유지되는지 검증하는 단계
- 쓰기 단계 : 검증 단계에서 충돌이 발견되지 않았다면 커밋

트랜잭션의 검증과 쓰기 단계는 원자적으로 수행돼야 한다. 트랜잭션을 검증하는 동안에는 다른 트랝개션은 커밋될 수 없다.

일반적으로 검증이 성공적이고 트랜잭션을 재시도할 필요가 없는 경우에 효율적이다.

### MVCC

여러 버전의 레코드를 저장하고 단조 증가하는 Tx ID 또는 타임 스탬프로 식별해 데이터베이스 트랜잭션의 일관성을 보장하는 동시성 제어 방식이다.

MVCC는 커밋된 값과 커밋되지 않은 값을 구분하고, 가장 마지막에 커밋된 값이 현재 값이다.

읽기 작업이 커밋되지 않은 값을 참조할 수 있는지에 대한 여부는 격리 수준에 따라 바뀔 수 있으며, MVCC로 구현된 대표적인 격리 수준은 스냅숏 격리다.

### 비관적 동시성 제어

트랜잭션 수행 중에 충돌 발생 가능성을 확인하고 계속 수행하거나 중단 또는 취소한다.

max_write_timestamp보다 낮은 타임스탬프가 설정된 트랜잭션이 값을 요청할 경우 이미 새로운 버전의 값이 존재하기 때문에 이 작업을 허용하면 트랜잭션 순서를 위반하게 된다.

마찬가지로 타임스탬프가 max_read_timestamp보다 낮은 쓰기 작업은 뒤에 실행된 읽기 작업과 충돌한다. 하지만 타임스탬프가 max_write_timestamp보다 낮은 쓰기 작업이 쓴 값은 무시해도 되기 떄문에 허용된다.

-> Thomas Write rule

### 잠금 기반 동시성 제어

타임스탬프 순서화 기법과 같은 스케줄링 기반이 아닌 데이터베이스 객체에 명시적으로 잠금을 설정하는 비관적 동시성 제어의 한 종류다. 경합현상 및 확장성 문제가 발생할 수 있다는 단점이 있다.

보편적인 잠금 기법은 2PL(Two-Phase Locking)이다.

- growing/expanding phase : 필요한 잠금을 획득하고 유지한다.
- shrinking phase : 획득한 잠금을 해제한다.

트랜잭션은 단 하나의 잠금이라도 해제하면 더 이상 다른 잠금을 획득할 수 없다.

**중요한 점은** 2PL은 어떤 단계에서도 트랜잭션 수행을 제한하지 않는다는 것이다.

***Dead Lock***

여러 트랜잭션이 잠금을 획득하는 과정에서 서로 사용 중인 잠금을 해제하기를 기다리는 상태를 교착 상태라고 한다.

타임아웃으로 해결할 수 있지만 동시성을 크게 저하시키기 때문에, 대부분의 데이터베이스는 트랜잭션 매니저를 통해 교착상태를 감지 빛 방지한다.

교착 상태는 일반적으로 동시 수행 중인 트랜잭션 간의 대기 상태를 그래프로 표현하는 wait-for-graph를 통해 감지한다.

트랜잭션 T2보다 우선순위가 더 높은 T1이 T2가 소유한 잠금을 요청한 경우
- 대기 또는 중지(wait-die) : T1은 잠금이 해제되길 기다리거나 중단 후 재시도한다.
- 선점 또는 대기(wound-wait) : T2는 중단 후 재시도 한다(T1이 T2를 중단시킨다)

***잠금***

잠금은 동시 수행 트랜잭션을 격리 및 스케줄링하고 데이터베이스의 상태를 관리하는 데 사용된다.

내부 스토리지 구조와는 무관하며 특정 키에 대해 요청할 수 있으며, 특정 키 또는 특정 범위의 키를 보호한다.

잠금은 래치보다 무겁고 트랜잭션이 수행되는 동안 유지된다.

***래치***

latch는 물리적 트리 구조(페이지와 트리 구조)를 보호하며 페이지에 대해 요청할 수 있다.

특정 페이지에 동시에 접근하기 위해서는 반드시 래치를 획득해야 한다.

소스 노드와 대상 노드 모두에 데이터가 존재하거나 데이터가 아직 상위 노드로 전파되지 않은 불완전한 쓰기 또는 노드 분할은 수행 중인 트랜잭션에서 볼 수 없도록 해서 상태의 일관성을 유지해야 한다.

***reader-writer 잠금 (RW Lock)***

***래치 크래빙***

Latch Crabbing
- 래치를 최대한 짧게 소유하고 작업을 수행하는데 래치가 필요하지 않다면 바로 해제한다.
- 자식 노드를 찾으면 즉시 해당 래치를 획득하고 부모 노드의 래치는 해제한다.
- 노드 삽입으로 인해 트리 구조가 변경되지 않을 것이 확실한 경우(자식 노드가 가득 찬 상태가 아니라면) 부모 레벨의 래치는 바로 해제한다.

***래치 업그레이드***

트리 탐색 중에 배타적 래치를 획득하지 않고 필요시 래치를 업그레이드 하는 방법도 있다.

탐색 경로를 따라 우선 공유 잠금을 획득하고 배타적 잠금으로 업그레이드 한다.

***Blink-tree***

B*-tree에 High Key와 형제 링크 포인터를 추가한 자료 구조다.

장점 : 자식 노드가 분할되더라도 부모 노드에 대한 잠금을 유지할 필요가 없다. 루트-리프 탐색 시 동시 접근을 단순화할 수 있다. **트리의 구조 변경과 읽기를 동시에 수행할 수 있으며, 부모 노드를 동시에 수정하려는 시도로 인해 발생하는 deadlock을 방지할 수 있다.**

단점 : 부모노드에서 바로 자식 노드를 참조하는 것보다 덜 효율적이고 접근해야 하는 페이지 수도 증가한다.

# B-트리 변형

- COW B-트리 : 노드를 수정할 수 없고 인플레이스 업데이트를 지원하지 않는다. 그 대신 페이지를 복사하고 업데이트한 뒤에 새로운 위치에 저장한다.
- lazy B-트리 : 동일한 노드에 대한 연속된 쓰기 작업의 I/O 요청 횟수를 줄이기 위해 수정 내용을 버퍼에 저장한다.
- FD-트리 : 작은 크기의 B-트리를 버퍼로 사용하고 버퍼가 가득 차면 그 내용을 불변 형태로 기록한다. 수정 사항은 상위 레벨에서 하위 레벨로 전파한다.
- Bw-트리 : B-트리 노드를 append only 방식으로 기록되는 여러 작은 그룹으로 나눈다. 여러 노드에 대한 쓰기 작업을 배치 단위로 처리해 비용을 낮춘다.
- cache-oblivious B- tree : 디스크 기반 자료구조를 인메모리 자료 구조처럼 사용한다.