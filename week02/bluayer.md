# Chapter 3. 파일 포맷

디스크 기반 B- 트리는 페이지 단위로 구성 및 탐색하기 때문에 일종의 페이지 관리 메커니즘

B-트리의 복잡성은 대부분 가변성으로 인해 발생

## 파일 포맷의 중요성

파일 포맷 설계
- 데이터 블록을 할당하고 고정 크기의 기본형과 자료 구조를 사용해 원하는 모양대로 블록을 잘라서 사용
- 큰 메모리 청크 또는 가변 길이의 자료 구조는 포인터를 사용해 참조

메모리 모델이 비관리형인 프로그래밍 언어 : 적당히 추가 할당 but 디스크상 : GC, 단편화 직접 관리

## 바이너리 인코딩

데이터를 효율적으로 저장하려면 컴팩트하고 직렬화와 역직렬화가 쉬운 포맷으로 인코딩해야 함

디스크에 저장된 데이터는 malloc, free 같은 원시 함수로 제어할 수 없고 오직 read와 write 함수 만을 사용할 수 있기 떄문에 접근 방식이 다르고 이에 맞는 형식으로 데이터를 저장 해야 함

효율적 페이지 레이아웃 설계?

### 기본형

integer, date, staring 등의 지정 자료형이 있고 바이너리 형식으로 표현할 수 있다.

대부분의 숫자형은 고정 길이 자료형.
- Big endian : MSB부터 시작해서 내림차순으로 저장. MSB가 가장 낮은 주소
- Litte endian : LSB부터 높은 자리 바이트까지 오름차순으로 저장한다.

레코드는 숫자 문자열, 불리언과 같은 기본형과 이들의 조합으로 구성된다.

레코드는 바이트 시퀀스 형태로 네트워크를 통해 전송되고 디스크에 저장한다.

따라서 전송 및 쓰기 전에 우선 serialize하고 수신 및 읽기 전에 deserialize해야 한다.

float and double : sign, fraction, exponenet

### 문자열과 가변 길이 데이터

문자열, 가변 길이 데이터는 배열의 크기 또는 문자열의 길이를 나타내는 숫자와 size 바이트 크기의 실제 데이터로 구성된다. (파스칼 문자열)

alternatives : null terminated 문자열

### 비트 묶음형 데이터 : 불리언, 열거형, 플래그

Packed boolean : 9개의 불리언 값이 각 1비트씩 사용하도록 묶어쓰기도 함

Packed boolean + Enum -> flag

상호배타적이지 않은 불리언 값들을 표현할 수 있으며 모든 비트가 플래그이기 때문에 2의 거듭 제곱만 지정 가능

## 파일 포맷 설계 원칙

주소 지정 방식(addressing)부터 결정 해야 함
- 파일을 단일 블록 vs 연속된 여러 블록으로 구성된 같은 페이지로 나눌 것인지
- 인플레이스 업데이트 지원 시 : 고정된 페이지 크기 사용
- Append only도 페이지 단위로 쓰는 경우 많음 (페이지가 차면 디스크로 플러시)

헤더 - 페이지 - 트레일러

대부분 스토어 : 테이블의 필드 수, 순서, 형식이 고정된 스키마가 존재

데이터베이스 파일 : 탐색에 유용한 lookup 테이블을 유지하고 각 레코드의 시작점을 가리키는 오프셋은 헤더와 트레일러 또는 개별 파일에 저장

## 페이지 구조

데이터 레코드 : 데이터 파일 + 인덱스 파일
파일 : 여러 파일시스템 블록을 합친 고정 크기의 페이졸 구성 (블록은 4kb ~ 16kb)

B- 트리 맥락에서 노드와 페이지(or block)의 의미는 같음

Triplet(Pointer -  key - value가 붙어 있는 구조)
- 장점 : 단순함
- 단점 : 오른쪽 빈 공간이 아닌 곳에 키 추가 시 여러 원소를 재배치 & 고정 길이 레코드 저장에는 적합하지만 가변 길이 레코드를 효율적으로 관리, 저장할 수 없다.


## 슬롯 페이지

가변 길이 레코드 저장 시 발생하는 가장 큰 문제는 삭제된 레코드의 공간을 회수하는 것.

페이지를 여러 개의 고정 길이 세그먼트로 분할하면 가변 길이 레코드를 저장할 수 있으나, 여전히 공간 낭비가 발생한다.

공간 회수 시 페이지를 재작성하고 일부 레코드를 재배치한다. 다만 다른 페이지에서 재배치된 데이터를 참조할 수 있기 떄문에 레코드의 오프셋은 유지해야 하며 메모리를 낭비하지 않도록 주의해야 한다.

결론 : 페이지 포맷은 다음 조건을 충족해야 한다.
- 최소한의 오베허드로 가변 길이 레코드 저장
- 삭제된 레코드의 메모리 회수
- 페이지의 레코드를 정확한 위치와 상관없이 참조

Slotted page or Slot directory를 사용하면 문자열, blob 과 같은 가변 길이 자료형을 효율적으로 저장 가능

페이지의 논리적 순서는 셀을 가리키는 포인터의 순서로 제어할 수 있으며, 레코드 삭제 시 해당 포인터를 삭제하거나 null로 설정. (페이지 내의 독립적인 영역에 포인터와 셀을 분리 저장하기 때문)

슬롯 페이지에는 페이지와 셀에 대한 정보를 헤더에 저장할 수 있음. 셀에는 키, 포인터, 레코드 등 임의 데이터 저장이 가능하며 셀마다 크기가 다를 수 있음

슬롯 페이지는 페이지 포맷 조건을 충족
- 오버헤드 최소화 : 실제 레코드 위치를 가리키는 포인터 배열 사용이 유일한 오버헤드다.
- 공간 회수 : 단편화 제거 및 페이지 재구성을 통해 공간을 회수할 수 있다.
- 동적 레이아웃 : 슬롯은 ID를 통해 페이지 외부에서 접근하기 때문에 정확한 위치는 페이지 내부에서만 필요하다.

## 셀 구조

셀 병합 -> 페이지, 페이지 병합 -> 트리

셀 : Key cell | Key-Value cell
- Key cell
    - 셀 종류
    - 키 길이
    - 셀이 가리키는 자식 페이지의 ID
    - 키 바이트 수
- Key-Value cell
    - 셀 종류
    - 키 길이
    - 값 길이
    - 키 바이트 수
    - 데이터 레코드 바이트

오프셋 & 페이지 ID
- 셀 오프셋 : 페이지 내부에서 시작 오프셋으로부터 상대적인 위치
- 페이지 ID : 고정 크기의 페이지는 페이지 캐시가 관리하기 때문에 id를 통해 룩업 테이블에서 오프셋 참조 가능

## 셀 병합으로 슬롯 페이지 구성

포인터는 키 순서대로 저장.
키는 삽입 순서대로 추가.

**셀을 삽입 또는 업데이트, 삭제해도 다른 셀을 재배치하지 않아도 됨**

## 가변 길이 데이터 관리

삭제 시 availability list에 회수된 메모리 크기와 해당 위치를 가리키는 포인터를 업데이트.

새로운 셀 삽입 전에 이 목록에서 적합한 세그먼트가 있는지 확인.

세그먼트 선택 전략
- First fit
- Best fit

새로운 셀을 저장할 수 있는 연속된 공간이 없다면,
1. 단편화 제거를 시도 -> 공간 확보
2. 공간 부족 시 -> 오버플로우 페이지 생성

## 버전 관리

스토리지 엔진 버전 변경 시 포맷도 바뀔 수 있음

## 체크섬
- 체크섬 : 다중 비트 오류는 감지 불가능 (XOR, Parity check, summation) & 보통 페이지 단위로 체크섬 계산해서 헤더에 저장
- CRC : burst error(다수의 연속 비트 손상 상황) 감지 가능 -> 의도적인 데이터 변경 및 변조 감지에는 적합하지 않음

# Chapter 4. B-트리 구현

## 페이지 헤더

탐색과 유지보수, 최적화에 필요한 페이지에 대한 정보 저장.

일반적으로 페이지 내용을 나타내는 플래그, 레이아웃, 셀 개수, 빈 공간을 가리키는 하한 & 상한 오프셋과 같은 몇 가지 유용한 메타데이터를 저장.

e.g.1 PostgreSQL은 페이지 크기와 레이아웃 버전을 헤더에 저장
e.g.2 MySQL InnoDB는 힙 레코드 개수와 레벨, 기타 구조 관련 값을 헤더에 저장
e.g.3 SQLite는 셀 개수와 가장 오른쪽 포인터를 저장

### 매직 넘버

상수 값을 포함하는 멀티 바이트 블록, 페이지 종류&버전과 같은 정보를 포함

검증, sanity check에도 사용

### 형제 링크
형제 페이지를 가리키도록 순방향, 역방향 링크를 저장.

부모 노드로 거슬러 올라가지 않고 이웃 노드를 바로 참조하지만, 분할 및 병합 시 이웃 오프셋까지 갱신해야 하기 때문에 더 복잡하다.

이렇게 구현되면 형제 노드에 대한 추가 잠금도 필요할 수 있음

### 가장 오른쪽 포인터

가장 오른쪽 포인터는 어떤 키와도 연관되지 않는 구분 키

SQLite는 마지막 포인터를 헤더에 저장하는 방식으로 구현

### High Key

가장 오른쪽 포인터와 노드의 High Key를 함께 저장하는 방법도 있다.
High Key는 현재 노드의 서브트리에 저장된 가장 큰 키.
이런 형식의 트리를 B link-트리라고 부르며 PostgreSQL에서 사용된다.

High Key를 통해 탐색 시 상한을 쉽게 찾을 수 있게 됨

### 오버플로우 페이지

노드 크기, 트리 팬아웃은 고정 값

- 큰 가변 길이 값을 트리에 저장하는 경우 : 값을 한 페이지에 저장하지 못할 수 있음
- 크기가 매우 작은 값 : 페이지의 많은 공간이 낭비

여러 페이지를 연결해서 데이터를 다른 연속된 공간으로 복사하지 않고 가변 크기 노드를 구현할 수 있음.

원본 페이지(primary page)와 기본 단위(e.g. 4K)로 새로 할당된 새로운 페이지(overflow page)를 연결

**SQLite 오버플로우 페이지 구현 방식 찾아보기**

Overflow Page의 관리
- 단편화 발생 가능
- 새로운 데이터를 쓰기 위해 공간 회수, 필요 없는 페이지 삭제 필요

특정 데이터를 찾기 위해 여러 오버 플로우 페이지를 확인해야 할 수 있음

모든 데이터의 사이즈가 크다면 블랍 스토리지 등의 사용을 고려해야 한다.

## 아진 검색

검색 키보다 큰 첫 번째 값을 찾고 해당 서브트리를 가리키는 포인터를 따라가는 탐색 경로가 중요하다.

### 간접 포인터를 사용한 이진 검색

중간 셀 오프셋을 선택하고, 해당 위치의 키와 검색 키를 비교해 진행방향을 결정해서 간다.

## 분할과 병합

부모 포인터도 부모가 변경되면 알맞게 갱신해야 한다.

Wired Tiger에서는 형제 포인터 사용으로 인해 발생할 수 있는 데드록을 제거하기 위해 리프 노드 탐색에 부모 포인터를 사용하기도 한다.

### 탐색 경로

부모 포인터를 저장 및 유지하는 대신 리프 노드까지의 경로를 저장해두고 노드 삽입과 삭제로 인한 분할 및 병합이 발생했을 때 저장된 경로를 역순으로 순회하는 방법도 있다.

e.g. PGSQL은 BTStack이라는 스택에 탐색 경로를 저장한다.
경로를 저장한 스택은 메모리에 유지한다.

https://github.com/postgres/postgres/blob/REL_12_STABLE/src/include/access/nbtree.h#L405-L423

### 리밸런싱

분할과 병합 비용을 줄이기 위해 레벨의 원소를 리밸런싱하거나 분할 및 병합을 수행하기 전에 상대적으로 빈 공간이 많은 노드로 요소를 옮긴다.

리밸런싱 비용이 높을 수도 있지만 노드의 점유율을 높이고 트리의 높이는 낮출 수 있다.

B*-트리는 형제 노드가 모두 가득 찰 때까지 이웃 노드 간에 원소를 분산한다.

두노드를 2/3가 채워진 3개의 노드로 분할하며, SQLite가 이 알고리즘을 사용한다.

** balance-siblings algorithmn

## 오른쪽 추가 기법

자동 증가값을 기본 인덱스 키로 사용하게 되면 모든 삽입이 인덱스 끝에서만 발생하기 때문에 대부분의 노드 분할 작업이 각 레벨의 가장 오른쪽 노드에서만 일어난다.

키가 단조 증가하기 때문에 추가가 업데이트나 삭제보다 많다면 키의 순서가 무작위일 때보다 단편화가 줄어든다.

PGSQL : Fast path
SQLite : Quickbalance

### 벌크 로딩

정렬된 데이터를 벌크 로딩하거나 트리를 재구성할 때에는 오른쪽 추가 알고리즘을 사용할 수 있다. 데이터가 이미 정렬되어 있기 떄문에 벌크 로딩 시 트리의 가장 오른쪽에만 데이터를 추가하면 된다.

미리 정렬된 데이터를 리프 레벨에 페이지 단위로 저장하는 방식으로 벌크 로딩을 구현할 수도 있다. 리프 페이지가 쓰이고 나면, 리프 페이지의 첫 번째 키를 부모 노드에 복사하고 상위 노드는 일반적으로 구성한다.

## 압축

 공간을 절약할 수 있는 압축 알고리즘을 제공하며, 압축 알고리즘에서 접근 속도와 압축률은 서로 상반된 관계다.

 일반적으로 데이터 셋이 클수록 작은 압축 단위가 적합하다.

인덱스 파일 전체를 압축한다면 파일 전체를 읽고 압축을 해제해야 해서 비효율적이다.

페이지 단위 압축을 사용하면, 데이터 전송이 블록 단위로 이뤄지기 때문에 압축된 페이지가 블록의 일부분만 차지한다면 더 많은 바이트를 읽는 비효율적인 상황이 발생한다.

블록 크기별 압축 알고리즘 성능을 비교하는 : Squash Compression Benchmark

## 정리와 유지

데이터 무결성 유지, 공간 회수, 오버헤드 최소화, 페이지 정렬 등 다양한 작업을 백그라운드에서 수행하면 시간을 절약할 수 있으며 삽입과 업데이트, 삭제 작업의 후처리 비용이 줄어든다.

### 업데이트와 삭제로 인한 단편화

삭제된 리프 레벨의 셀은 헤더에서 오프셋만 제거하고 실제 셀은 남겨둔다.

페이지가 분할되면 페이지의 일부는 더 이상 참조할 수 없기 때문에 해당 오프셋은 삭제되며 삭제된 오프셋의 셀은 새 데이터로 덮어쓰거나 GC가 처리한다.

일반적으로 데이터를 삽입하려면 셀 크기에 맞는 연속된 바이트 블록이 필요하기 때문에 여러 조각을 모아 연속된 공간을 확보하려면 페이지 재구성이 필요하다. 

리프 노드에 대한 업데이트 작업 시 셀 순서는 변경하지 않고 페이지 재구성을 최소화한다. 따라서 셀의 여러 버전이 조재할 수 있고 이 가운데 한 개의 버전만 접근할 수 있다.

### 페이지 단편화

페이지에 사용 가능한 물리적 공간이 부족한 경우, 오버플로우 페이지 생성을 방지하기 위해서 컴팩션과 쓰기를 동시에 수행할 수 있다. 하지만 일반적으로 비동기적 과정을 일컫는다.

- 데드 셀이 차지하는 공간을 회수하고 셀을 논리적 순서로 재구성
- 사용 중이지 않은 인메모리 페이지는 사용 가능상태로 변경되고 페이지 캐시에 반환
- 디스크에 새로 할당된 페이지 ID는 free page list에 추가 (노드 장애, 재부팅 시에도 유지되어야 함)