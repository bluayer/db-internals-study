# 3장 파일 포맷

애플리케이션 개발자 관점에서는 **메모리 접근**이 거의 투명하다. **가상 메모리**를 사용하면 직접 **오프셋**을 관리할 필요가 없다.

하지만 디스크는 **시스템 콜**을 사용해서 접근할 수 있다.
파일 내의 **오프셋**을 직접 지정해야 하며,
디스크 상의 표현을 메모리에서 읽을 수 있는 형태로 **직접 변환**해야 한다.

따라서 효율적인 **디스크 기반 자료 구조**를 설계하기 위해서는 이러한 차이점을 잘 고려해야 한다.
따라서 생성, 수정, 해석이 쉬운 **파일 포맷**을 설계하는 것 또한 중요하다.

디스크 기반 자료 구조도 **포인터**를 사용하지만, 인메모리 자료 구조의 **포인터 관리**와는 다르다.
예를 들어 디스크 기반 B-트리는 **페이지 단위**로 구성되고, 탐색하기 때문에 **페이지**를 관리하는 것에 가깝다.
페이지를 잘 **구성**하고, 페이지를 가리키는 **포인터**를 잘 **배치**할 필요가 있다.

## 파일 포맷의 중요성

파일 포맷을 설계하는 것은 **메모리 모델이 비관리형인 언어**로 자료 구조를 설계하는 것과 비슷하다.
**데이터 블록**을 할당하고, **고정 크기**의 기본형, 자료구조를 사용해 **블록을 잘라서 사용한다.**
**큰 메모리 청크**나, **가변 길이** 자료 구조는 **포인터**를 사용해서 참조한다.

다만 여전히 메모리의 데이터 레이아웃이 디스크보다 단순하다.
디스크의 경우 **영속적 저장 장치**의 특성을 이해해 **빠르게 접근**할 수 있는 형태로 저장해야 한다.
또한 **바이너리 포맷 구조**를 설계하고, 빠르게 **직렬화/역직렬화** 할 수 있는 수단도 마련해야 한다.

데이터를 **메인 메모리**에 저장하고, 적절히 **써드파티 라이브러리**를 이용하면 **메모리 레이아웃**과 관련된 문제를 해결할 수 있다. **메모리 할당**과 **포인터**를 사용할 수 있으므로 특별한
레이아웃이 필요하지 않다.

그러나 디스크 기반 자료구조의 경우 그렇지 않으며, **운영체제**나 **파일시스템**이 일부 문제를 해결해주긴 하지만 여전히 많은 부분을 신경써야 한다.

## 바이너리 인코딩

데이터를 효율적으로 디스크에 저장하려면 크기가 작고, 효율적으로 직렬화/역직렬화 할 수 있는 포맷을 선택해야 한다.
> 레코드를 디스크에 저장할 때도 바이트 시퀀스 형태를 사용하지만, 네트워크를 통해 전송할 때도 바이트 시퀀스를 사용한다.

디스크의 경우 `malloc`이나 `free`와 같은 원시 함수를 사용할 수 없고, 오직 `read`, `write` 함수만 사용할 수 있기 때문에 메모리와 완전히 접근 방식이 다르고, 이에 맞는 형식을 사용해야
한다.

## 기본형

**키**와 **값**은 `integer`, `date`, `string` 등 지정된 **자료형**이 있고, **바이너리 형식**으로 표현할 수 있다.

대부분의 숫자형은 **고정 길이 자료형**이다.
멀티 바이트인 경우 같은 **바이트 순서**를 사용해야만 한다.

- 리틀 엔디언
- 빅 엔디언

부동소수점의 경우 부호, 가수, 지수로 구성된다.
![](files/Pasted%20image%2020230808190213.png)

## 문자열과 가변 길이 데이터

**모든 기본형 데이터의 크기는 고정**되어 있다.
여러 기본형 값을 조합해 하나의 자료구조를 만들거나, **고정 길이 배열**이나 **포인터**를 사용해서 다른 메모리를 참조한다.
> 단, CPU의 작동 또는 최적화를 위해서 컴파일러가 padding을 추가하는 경우도 있다. -> Self-Aligned

**USCD 문자열**, 또는 **파스칼 문자열**의 경우 **문자열**과 **가변 길이 자료형**을 **크기**와 **데이터**로 구성한다.

```
String
{
	size unit_16
	data byte[size]
}
```

파스칼 문자열의 대안은 널 종단(null terminated) 문자열이다. 바이트 단위로 문자열 끝 기호에 도달할 때까지 읽는다.
파스칼 문자열은 길이를 상수 시간 안에 알 수 있다.

## 비트 묶음형 데이터 : 불리언, 열거형, 플래그

**불리언** 자료형은 **단일 바이트** 또는 `true`, `false`를 `0`과 `1`로 **인코딩**한 값이다.
바이트 전체를 사용하는 것이 낭비이므로 8개의 불리언 값을 하나의 바이트로 묶어서 쓰기도 한다. -> packed 불리언

**Enum**은 열거형의 줄임말이며 **숫자**를 표현한다.
가짓수가 적고 자주 반복해서 사용하는 값을 표현할 때 사용한다.

또 다른 자료형으론 **플래그(flag)** 가 있다. **상호배타적**이지 않은 **불리언** 값들을 표현한다.
각 **비트**를 플래그로 사용하므로 **2의 거듭제곱**을 지정해서 사용한다.

```c
int IS_LEAF_MASK = 0x01h;
int VARIABLE_SIZE_VALUES = 0x02h;
int HAS_OVERFLOW_PAGES = 0x04h;
```

## 파일 포맷 설계 원칙

파일 포맷을 설계할 때는 **주소 지정 방식**부터 결정해야 한다.
파일을 **같은 사이즈**의 **페이지**로 나눌 것인지부터 선택해야 한다.
이때 페이지는 **단일 블록**, 혹은 **연속된 블록**들로 구성될 수 있다.

![](files/Pasted%20image%2020230808203248.png)
일반적으로 파일은 **고정 크기의 헤더**로 시작한다. 경우에 따라서 끝 부분에 **고정된 크기의 트레일러**가 있을 수도 있다.
빠르게 접근하거나, 파일 **디코딩**을 위한 **부가 정보**가 들어간다.
파일의 나머지 부분은 **페이지**로 나눠서 저장한다.

대부분 **필드 수**, **순서**, **형식**이 **고정된 스키마**가 있으므로 **위치**를 활용하면 데이터의 크기를 줄일 수 있다.

![](files/Pasted%20image%2020230808204114.png)
만약 다음과 같은 필드 구성이 있다고 하면 가변 길이 필드를 고정 길이 필드 뒤에 저장할 수도 있다.
`first_name` 필드는 고정 길이 필드의 끝에서 `first_name_length` 바이트만큼만 읽으면 되며, `last_name`의 위치는 앞 필드의 길이를 확인해서 얻을 수 있다.

계산을 줄이기 위해서 **오프셋**과 **길이**를 기록하면 가변 길이 필드도 개별적으로 접근할 수 있다.
> ?

더 복잡한 파일 구조는 더 복잡한 **계층 구조**가 필요하며, 다음과 같을 수 있다.

- 리전
    - 섹션
        - 페이지
            - 셀
                - 필드
                    - 기본형
                      그러나 반드시 따라야 하는 규칙은 아니다. 어떤 형식의 데이터 포맷을 설계하느냐가 중요하다.

데이터베이스 파일은 일반적으로 여러 부분으로 구성된다.
**룩업 테이블(LUT, lookup table)** 을 유지하고, 각 레코드의 시작점을 가리키는 **오프셋**은 **헤더**와 **트레일러**, 또는 **개별 파일**에 저장한다.

> 데이터베이스의 LUT는 레코드 수나 인덱스 통계 등을 의미하는 것인지?

## 페이지 구조

데이터 레코드는 **데이터 파일**과 **인덱스 파일**에 저장된다.
**파일**은 여러 **블록**을 합친 **고정 크기의 페이지**로 구성된다.
블록의 크기는 4kb부터 16kb까지 다양하다.

B-트리 노드의 경우 다음과 같이 구성된다.

- 리프 노드
    - 키와 데이터 레코드
- 비리프 노드
    - 키와 다른 노드를 가리키는 포인터

B-트리 노드는 단일 페이지, 또는 연결된 여러 페이지로 구성되므로 B-트리에서 **노드**와 **페이지**의 의미는 같다.

B-트리를 처음 발표한 논문의 고정 길이 데이터의 페이지 구조를 살펴보면 다음과 같다.
![](files/Pasted%20image%2020230808210812.png)
(p, k, v)로 구성된 여러 트리플렛을 연결한 구조다.

- p : 자식 페이지를 가리키는 포인터
- k : 키
- v : 값

단순하지만 아래와 같은 단점이 있다.

- 오른쪽 빈 공간이 아니라 중간에 키를 삽입하기 위해서는 여러 원소의 **재배치**가 필요하다
- **고정 길이 레코드** 저장에는 적합하지만 **가변 길이 레코드**를 효율적으로 다룰 수 없다.

## 슬롯 페이지

**가변 길이 레코드**를 저장할 때 가장 문제가 되는 부분은 삭제된 레코드의 **공간을 회수**하는 것이다.
`m` 길이의 레코드가 저장되어있던 곳에 `n` 길이의 레코드를 저장한다면 `m == n`이라면 공간을 낭비없이 활용할 수 있지만 그렇지 않다면 `m - n` 길이의 레코드가 있어야 낭비 없이 활용할 수 있다.
만약 `m < n`이라면 저장할 수도 없다.

**페이지**를 **고정된 길이의 세그먼트**로 **분할**하면 가변 길이 레코드를 저장할 수 있지만 여전히 **공간 낭비**가 생긴다.
만약 세그먼트 크기가 64 바이트라면 64 바이트의 배수가 아닐 경우 나머지 만큼의 공간이 낭비된다. (일종의 **내적 단편화**)

공간을 **회수**할 때는 **페이지**를 **재작성**하고, **일부 레코드**를 **재배치**한다.
단, 다른 페이지에서 재배치된 레코드를 참고할 수 있도록 **레코드의 오프셋**은 유지해야 한다.

즉, 페이지 포맷은 다음을 만족해야 한다.

- 최소한의 오버헤드로 가변 길이 레코드 저장
- 삭제된 레코드의 메모리 회수
- 페이지의 레코드를 정확한 위치와 상관없이 참조

**슬롯 페이지**나 **슬롯 디렉터리**를 사용하면 문자열, BLOB와 같은 **가변 길이 자료형**을 효율적으로 저장할 수 있다.
> PostgreSQL이 이 방식을 사용한다.

![](files/Pasted%20image%2020230808212419.png)

**페이지**는 **슬롯** 또는 **셀**의 집합이다.
페이지 내 **독립**적인 영역에 **포인터**와 **셀**을 분리해서 저장한다.
덕분에 **레코드의 논리적 순서**는 **포인터의 순서**로 나타낼 수 있다.
레코드를 삭제하게 되면 해당 포인터를 삭제하거나, null로 바꾼다.

**슬롯 페이지**는 페이지와 셀에 대한 중요한 정보를 저장하는 **고정 길이 헤더**가 있다.
셀에는 **키**, **포인터**, **레코드** 등 다양한 데이터를 저장할 수 있다.
셀마다 **크기**가 달라질 수 있다.

슬롯 페이지는 앞에서 말한 조건을 모두 충족한다.

- 오버헤드 최소화
    - 포인터 배열을 관리하는 것이 유일한 오버헤드다.
- 공간 회수
    - 단편화 제거, 페이지 재구성을 통해 공간을 회수할 수 있다.
- 동적 레이아웃
    - 페이지 외부에서 ID로 슬롯에 접근하므로 정확한 위치는 페이지 내부에서만 필요하다.

## 셀 구조

**플래그**, **열거형**, **기본형**을 사용해서 **셀 레이아웃**을 설계할 수 있다.

- 트리
    - 페이지
        - 셀
            - 키 셀
                - 구분 키, 인접한 두 페이지를 가리키는 포인터
            - 키-값 셀
                - 키, 데이터 레코드

같은 페이지의 셀은 모두 **형식**이 같다고 가정하기에, 셀 정보를 **페이지 레벨**에만 저장하면 된다.
> 같은 페이지의 모든 셀은 키 셀 또는 키-값 셀이다.
> 모든 셀의 데이터 길이는 가변 또는 고정이며, 혼합될 수 없다.

키 셀은 다음으로 구성된다.

- 셀 종류
    - 페이지 메타데이터에 저장된다
- 키 길이
- 셀이 가리키는 자식 페이지의 ID
- 키 바이트 수

```
0                4               8
+----------------+---------------+-------------+
| [int] key_size | [int] page_id | [bytes] key |
+----------------+---------------+-------------+
```

예를 들어 가변 길이 키 셀은 다음 구조로 저장될 수 있다.
만약 고정 길이 키 셀이라면 길이를 나타내는 필드는 불필요하다.

고정 길이 필드는 앞에 저장하고, `key_size` 바이트 크기의 필드는 따로 모아서 저장할 수도 있다.
반드시 이 구조를 따라야 하는 것은 아니지만 **오프셋 계산**이 쉽다는 장점이 있다.
미리 계산된 정적 오프셋을 통해 고정 길이 필드에 접근하고, 가변 길이 데이터의 오프셋만 따로 계산하면 된다.

키-값 셀은 **자식 페이지 ID** 대신 실제 **데이터**를 저장한다.

- 셀 종류
    - 페이지 메타데이터에 저장된다
- 키 길이
- 값 길이
- 키 바이트
- 데이터 레코드 바이트

```
0             1                5                  9
+-------------+----------------+------------------+
| [byte] flag | [int] key_size | [int] value_size | 
+-------------+----------------+------------------+
9         9 + key_size
+-------------+---------------------+
| [bytes] key | [bytes] data_record |
+-------------+---------------------+
```

페이지 ID와 오프셋은 구분할 필요가 있다.

**고정 크기의 페이지**는 **페이지 캐시**가 관리한다.
따라서 **페이지 ID**를 통해 **룩업 테이블**에서 **오프셋**을 참조할 수 있다.

그러나 **셀 오프셋**은 **페이지 내부**에서 **시작 오프셋**으로부터의 **상대적인 위치**를 나타낸다.
덕분에 **작은 숫자**로 위치를 나타낼 수 있다.

셀 안의 키와 값이 꼭 고정 길이일 필요는 없다. 모두 가변 길이여도 괜찮다.
`key_size`, `value_size` 를 통해서 적절히 오프셋을 계산하면 저장 위치를 찾을 수 있다.
물론 헤더로부터 계산하는 것이 아니라, 전체 길이를 저장하고 뺄셈으로 위치를 찾을 수도 있다.

## 셀 병합으로 슬롯 페이지 구성

![](files/Pasted%20image%2020230808224300.png)
**슬롯 페이지 방식**을 사용하면 **셀**을 병합해서 **페이지**를 구성할 수 있다.
**셀**은 **오른쪽** 끝에 추가하고, **셀 오프셋/포인터**는 **왼쪽**에 추가한다.

**키**는 **삽입 순서**대로 추가하고, 셀 오프셋 **포인터**는 **키 순서**대로 저장하면 **논리적 순서**를 유지할 수 있다.
또한 셀을 삽입, 업데이트, 삭제해도 다른 셀을 **재배치**할 필요가 없다는 장점이 있다.

![](files/Pasted%20image%2020230808224645.png)
**셀**은 **삽입 순서**대로 배치되고, **오프셋**은 **이진 탐색**이 가능하도록 **정렬**된다.
![](files/Pasted%20image%2020230808224658.png)
새로운 데이터가 삽입되면 오프셋의 정렬을 유지하기 위해서 포인터가 이동될 수도 있다.
그러나 셀은 삽입 순서대로 추가된다.

## 가변 길이 데이터 관리

**페이지 레코드**를 삭제할 때 실제 셀을 지우고, 다른 셀을 옮길 필요는 없다.
삭제된 셀이라고 **표시**하고, **사용 가능 목록(availability list)** 에 **회수된 메모리 크기**와 해당 위치를 가리키는 **포인터**만 추가하면 된다.

따라서 **사용 가능 목록**에는 사용할 수 있는 세그먼트의 크기와 위치가 저장된다.
새로운 셀을 삽입할 때는 먼저 사용 가능 목록에서 적합한 세그먼트가 있는지 확인한다.

![](files/Pasted%20image%2020230808225018.png)

**SQLite**는 사용하지 않는 세그먼트를 **프리블록(freeblock)** 이라고 부른다.
그리고 첫 번째 프리블록을 가리키는 포인터를 **페이지 헤더**에 저장한다.
더 나아가 단편화 제거 후 새로운 레코드를 한 페이지에 저장할 수 있는지 빠르게 판단할 수 있도록 페이지에 남아있는 바이트 수를 가지고 있다.

셀을 저장할 때 세그먼트를 선택하는 전략은 크게 두 가지가 있다.

- 최초 적합(first fit)
    - 첫 번째로 찾은 적합한 세그먼트를 선택한다
    - 남은 공간이 또 다른 셀을 저장해 크기가 작을 수 있으므로 오버헤드가 발생할 수 있다
        - ??
- 최적 적합(best fit)
    - 레코드를 저장할 수 있는 가장 작은 세그먼트를 선택한다

새로운 셀을 저장할 공간이 없는 경우, 모든 셀을 **재배치**해 **페이지의 단편화**를 제거하면 새로운 셀을 **연속된 공간**에 저장할 수 있다.
하지만 **단편화**를 제거해도 공간이 부족하다면 **오버플로우 페이지**를 생성해야 한다.

> 지역성을 높이기 위해서 리프 레벨의 키와 값을 따로 저장하기도 한다. 키를 모아서 저장하면 지역성이 높아진다.
> 키를 찾은 뒤 해당 인덱스를 통해 값 셀에 접근할 수 있다.

페이지, 셀은 결국 다음과 같이 구성된다.

- 페이지
    - 고정 길이 헤더
    - 셀 포인터 블록
    - 셀
        - 키
        - 자식 노드 or 데이터 레코드를 가리키는 포인터

결국 B-트리는 **계층형 포인터**로 구성된다.
**페이지 식별자**로 **트리 파일**에서 **노드**를 찾고, **셀 오프셋**으로 **페이지**에서 **셀**을 찾을 수 있다.

## 버전 관리

데이터베이스 시스템은 지속적으로 발전하기 때문에 파일 포맷이 변경될 수도 있다.
일반적으로 스토리지 엔진은 한 개 이상의 직렬화 포맷을 지원한다.

따라서 파일 버전은 매우 중요한 정보인데 다음과 같은 방법들이 있다.

- 파일명의 접두사를 이용해서 버전을 기록
- 별도 파일에 기록
- 인덱스 파일 헤더에 버전 명시
- 매직 넘버를 사용

## 체크섬

디스크에 저장된 파일은 손상될 수 있다.
이 문제가 다른 시스템에 전파되는 것을 막기 위해서 **체크섬(checksum)** 또는 **CRC(Cyclic Redundancy Check)** 등을 사용한다.

해시 함수, CRC, 체크섬 모두 큰 데이터를 작은 데이터로 줄인다는 공통점이 있지만 **목적**과 **보장성(Guarantee)** 은 모두 다르다.

- 체크섬
    - 보장성이 매우 낮다
    - 다중 비트 오류는 감지할 수 없다
    - XOR이나 패리티 검사, 합 등을 사용한다.
- CRC
    - 버스트 오류(burst error, 다수의 연속된 비트가 손상된 상황)을 감지할 수 있다.
    - 룩업 테이블과 다항식의 나눗셈을 사용한다.
    - 일반적으로 네트워크, 스토리지에서 발생하는 오류는 멀티비트 오류이므로 유용하며, 그래서 빠른 감지가 중요하다.
    - 보안을 위한 목적으로는 적합하지 않다. 의도하지 않은 데이터 변경 감지에는 좋지만 의도적인 변경을 감지하는데는 적합하지 않다.

데이터의 체크섬을 미리 계싼하고, 나중에 비교하는 형태로 데이터 손상을 감지한다.

파일 전체에 대한 체크섬 계산은 너무 비효율적이다.
따라서 페이지 단위로 체크섬을 계산하고, 페이지 헤더에 저장한다.
덕분에 체크섬 계산도 빠르고, 더욱 견고해지며, 특정 페이지 손상을 감지할 수 있다.

# 4장 B-트리 구현

## 페이지 헤더

**페이지 헤더**에는 탐색, 유지보수, 최적화에 필요한 **페이지 정보**를 저장한다.
플래그, 레이아웃, 셀 개수, 빈 공간을 가리키는 오프셋 등 **메타데이터**를 저장하는데 DB에 따라 또 다르다.

## 매직 넘버

**파일 헤더**나 **페이지 헤더**에 매직넘버가 기록되기도 한다.
**매직넘버**는 일반적으로 **상수** 값을 포함하는 **멀티바이트** 블록이며 페이지의 **종류**나 **버전** 정보 등을 포함하기도 한다.

매직 넘버는 **검증**이나 **상태 체크**에도 사용될 수 있다. 임의의 오프셋 바이트 열이 매직 넘버와 정확히 일치할 확률이 매우 낮기 때문이다.

> 그 다음 내용은..?

## 형제 링크

좌우에 있는 **형제 페이지**를 **부모 노드**를 거치지 않고 이동할 수 있도록 링크를 저장하기도 한다.
즉, 좌우 형제 페이지를 가리키는 순방향 링크, 역방향 링크를 저장한다.
![](files/Pasted%20image%2020230809215144.png)
![](files/Pasted%20image%2020230809215251.png)
**부모 노드**는 **직속 자식 노드**만 가리키므로 운이 안좋으면 형제 노드에 접근하기 위해서 **루트 노드**까지 올라가야 할 수도 있다.
**헤더**에 **형제 링크**를 저장하면 **같은 레벨**의 이전 노드, 다음 노드에 **빠르게 접근**할 수 있다.

다만 분할, 병합시 이웃 오프셋까지 갱신해야 하므로 더 복잡하다. 분할과 병합의 대상 노드 뿐만 아니라 형제 노드까지 업데이트하므로 추가적인 잠금이 필요할 수도 있다.

## 가장 오른쪽 포인터

B-트리의 구분키의 주 역할은 트리를 서브트리로 분할하는 것이다.
따라서 자식 페이지를 가리키는 포인터는 항상 구분키의 개수보다 하나 더 많다.

![](files/Pasted%20image%2020230809221135.png)
각 구분키에는 자식 포인터가 있으며, 마지막 포인터는 따로 저장된다.
> SQLite는 마지막 포인터를 헤더에 저장한다

![](files/Pasted%20image%2020230809221304.png)
가장 오른쪽 자식 노드가 **분할**되면서 새로운 노드가 추가되는 경우 부모의 **마지막 포인터**도 다시 설정된다.
부모 노드에 추가된 셀의 승급키가 분할된 노드를 가리키며, 마지막 포인터가 새로운 노드를 가리킨다.

## 하이 키

가장 오른쪽 포인터와 노드의 **하이 키(high key)** 를 함께 저장하는 방법도 있다.
**하이 키**는 현재 노드의 서브트리에 저장된 **가장 큰 키**를 나타낸다. 이러한 방법을 사용한 트리를 **B link-트리**라고 부르며, PostreSQL에서 사용된다.

하이 키(K)는 해당 서브트리에서 저장할 수 있는 최댓값이 되며 탐색 공간이 +∞에서 K로 줄어든다.
![](files/Pasted%20image%2020230809221854.png)
![](files/Pasted%20image%2020230809221905.png)

## 오버플로우 페이지

노드의 **크기**와 트리 **팬아웃**은 **고정값**이다.
모든 상황에 최적인 값은 없기에 매우 **큰** 가변 길이의 값을 저장하려고 하면 **한 페이지**에 담을 수 없다거나, 크기가 매우 작아 페이지의 많은 **공간이 낭비**되는 현상 등이 발생할 수도 있다.

B-트리 알고리즘에서 모든 노드는 **일정 개수의 키**를 유지해야 한다.
그러나 각 노드에 저장되는 값 크기는 다 다르기에 **노드**는 공간이 남아있지만 해당 노드의 **고정 크기의 페이지**에 공간이 없을 수도 있다.

페이지 크기를 변경하게 되면 기존 데이터를 **복사**해야 하므로 **비효율적**이다.
그러나 페이지 크기 증가, 확장은 불가피하다.

**여러 페이지**를 **연결**하면 데이터를 **연속된 공간**에 **복사**하지 않고 **가변 크기 노드**를 구현할 수 있다.
페이지에 공간이 모자라면 새로운 페이지를 할당하고 원본 페이지에 연결한다.
새로운 페이지를 **오버플로우 페이지(overflow page)** 라고 하며, 원본 페이지를 **기본 페이지(primary index)** 라고 한다.

대부분의 B-트리는 **고정 크기의 바이트**만 **노드**에 저장하고, 나머지는 **오버플로우 페이지**에 저장한다. **고정 크기**는 **노드 크기**를 **팬아웃**으로 나눈 값이다.
페이지에는 최소 `max_payload_byte` 바이트만큼의 공간이 남아있으므로 페이지에 공간이 부족한 일은 발생하지 않는다.

삽입된 데이터가 `max_payload_byte`보다 크다면 노드에 연결된 **오버플로우 페이지**를 찾는다.
오버플로우 페이지가 존재하고, 공간이 남으면 거기에 저장하고 없으면 새로 생성한다.

![](files/Pasted%20image%2020230809223529.png)
**오버플로우 페이지**도 기본 페이지처럼 **단편화**가 발생할 수 있다. 공간 회수나 필요 없는 페이지를 삭제하는 등의 관리가 필요하다.

첫 **오버플로우 페이지**를 할당하면 **페이지의 ID**를 **기존 페이지 헤더**에 저장한다. 그 이후 새로운 **오버플로우 페이지의 ID**는 각 **헤더**에 **다음 페이지 ID**를 저장하고 연결한다.
따라서 특정 데이터를 찾기 위해서 여러 오버플로우 페이지를 방문해야 할 수도 있다.

키의 **카디널리티**는 일반적으로 높고, **기본 페이지**에 저장된 키가 비교 대싱이므로 키를 나눠서 저장해도 된다.

**데이터 레코드**가 요청되면 **오버플로우**된 부분을 찾아서 반환해야 한다. 단, 일반적으로 이런 요청이 자주 발생하진 않는다. 만약 모든 데이터의 사이즈가 크다면 BLOB 스토리지 등의 사용을 고려해봐야
한다.

## 이진 검색

B-트리 탐색 알고리즘은 이진 검색 알고리즘을 사용한다.
데이터가 정렬된 경우에만 사용할 수 있으므로 정렬된 키로만 검색 가능하다.

삽입 위치는 검색 키보다 첫 번째로 큰 값의 위치이며, 이 위치의 절댓값에 삽입하면 키 정렬 상태가 유지된다.
삽입 시에는 삽입 위치 이후의 모든 원소를 한 자리씩 이동시켜 새로운 값을 위한 공간을 만들고 삽입한다.

## 간접 포인터를 사용한 이진 검색

B-트리 **페이지**의 **셀**은 **삽입 순서**대로 저장되며, **셀 오프셋**만 **논리적 순서**를 유지한다.
![](files/Pasted%20image%2020230809225003.png)
셀의 이진 검색은 중간 오프셋을 선택하고, 값에 따라서 왼쪽, 오른쪽 진행 방향을 결정한다.

## 분할과 병합

노드의 분할과 병합은 **상위 노드**까지 전파될 수 있다.
따라서 분할하는 리프노드, 병합하는 리프노드로부터 루트 노드까지 순회할 수 있어야 한다.

그래서 일부 B-트리는 노드에 부모 노드를 가리키는 포인터를 저장한다.
하지만 하위 레벨의 페이지는 항상 바로 위 레벨로부터 참조되기 때문에 부모 노드 정보는 디스크에 저장하지 않아도 된다.

> 디스크에 저장하지 않아도 이전 참조 정보를 활용해서 접근할 수 있다는 뜻?

형제 포인터와 마찬가지로 부모 포인터도 적절히 갱신해줄 필요가 있다.

형제 포인터를 사용하면 잠금이나 데드록에 대한 고려가 필요하다. 그래서 일부 트리는 리프 노드 탐색에 **부모 포인터**를 사용하기도 한다.

## 탐색 경로

부모 포인터를 저장하는 대신 리프 노드까지의 경로를 저장해두고, 분할, 병합이 발생했을 때 저장된 경로를 **역순**으로 순회하는 방법도 있다. **탐색 경로**는 루트부터 방문한 모든 노드에 대한 정보를 포함한다.
경로를 저장한 스택은 메모리에 유지한다.

B-트리 구조 변경을 위해서는 리프 노드 또는 삽입 지점까지 트리를 순회해야 한다.
하지만 리프 노드에 도달하기 전에는 분할이나 병합 발생 여부를 알 수 없기 때문에 **탐색 경로**를 저장해야 한다.

리프 노드를 분할해야 한다면 스택의 최상위 요소를 참조해 부모 노드를 찾는다. 만약 부모 노드에 남는 공간이 없다면 부모 노드도 분할해야 한다. 루프 노드에 도달해 스택에 더 이상 남은 요소가 없거나, 분할하지
않아도 될 때까지 반복한다.

![](files/Pasted%20image%2020230810204244.png)

## 리밸런싱

일부 B-트리 구현은 **분할, 병합 비용**을 줄이기 위해서 레벨 내 노드를 **리밸런싱**하거나, 분할, 병합 작업을 수행하기 전에 빈 공간이 많은 노드로 **원소를 이동**한다.
이 경우 **리밸런싱 비용**이 높아질 순 있지만 노드의 **점유율**을 높이고 트리의 **높이**를 낮출 수 있다.

노드 삽입, 삭제할 때 **로드 밸런싱**을 수행하는 방법도 있다.
**효율적인 공간 활용**을 위해 노드를 **분할**하는 대신 일부 **원소를 옮기고**, 삽입할 **공간을 확보**한다.
삭제작업 할 때도 형제 노드와 **병합**하는 대신 노드가 절반 이상 찬 상태를 유지하도록 형제 노드에서 일부 **원소를 가져올 수도 있다.**

B*-트리는 형제 노드가 모두 가득 찰 때까지 이웃 노드 간에 원소를 분산한다.
노드를 절반이 찬 두 개의 노드로 분할하는 것이 아니라, 2/3이 찬 3개의 노드로 분할한다.
> SQLite에서 이 방법을 사용한다.

이 방식은 분할을 지연시켜 **평균 점유율**을 높일 수 있지만, 상태를 관리하고 균형을 맞추는 로직이 추가로 필요하다.
하지만 **높은 점유율** 덕분에 트리 **높이**가 낮아지고, 순회 시 참조 페이지가 적어져 **검색 효율성**이 높아진다.

![](files/Pasted%20image%2020230810205324.png)

로드 밸런싱은 많은 데이터베이스 구현에서 사용하는 유용한 기술이다.
SQLite는 이와 비슷한 형제 밸런싱(balance-siblings) 알고리즘을 사용한다.

## 오른쪽 추가 기법

많은 데이터베이스 시스템이 자동 증가 값을 기본 인덱스 키로 사용한다.
모든 삽입이 인덱스 끝에서만 발생하므로 대부분의 노드 분할 작업이 각 레벨의 가장 오른쪽 끝 노드에서 일어난다. 최적화하기 좋다.
또한 키 업데이트, 삭제가 추가보다 자주 발생하지 않으면 내부 노드 단편화는 키가 정렬되지 않았을 때보다 감소한다.

PostgreSQL는 이런 방식을 패스트패스(fastpath)라고 부른다. 삽입하는 키가 가장 오른쪽 페이지의 첫 번째 키보다 크고, 가장 오른쪽 페이지에 공간이 있다면 탐색하지 않고 캐시된 페이지에 바로 삽입한다.

SQLite도 퀵밸런스(quickbalance)라는 개념을 사용한다. 빈 공간이 없는 가장 오른쪽 노드에 데이터 추가 시 균형을 맞추거나, 분할하는 대신 오른쪽에 새로운 노드를 할당하고 부모 노드에 포인터를
추가한다.
새로 할당된 노드는 거의 비어있지만 곧 채워질 가능성이 매우 높다.

## 벌크 로딩

정렬된 데이터를 벌크 로딩하거나, 트리를 재구성할 때에는 우측 추가 알고리즘을 사용할 수 있다.
데이터가 이미 정렬되어 있으므로 벌크 로딩시시 트리의 가장 오른쪽에만 데이터를 추가하면 된다.

트리를 하위 레벨부터 상향식으로 구성하거나, 상위 노드를 쓰는 방식으로 트리를 구성하면 노드의 분할과 병합을 피할 수 있다.

미리 정렬된 데이터를 개별 삽입하는 대신 리프 레벨에 **페이지 단위**로 저장하는 방식으로 벌크 로딩을 구현할 수도 있다.
리프 페이지를 생성하고, 리프 페이지의 첫 번째 키를 부모 노드에 복사하고 상위 레벨은 B-트리 알고리즘으로 구성한다.
이 경우에도 데이터는 이미 정렬되어 있으므로 노드 분할은 가장 오른쪽 노드에서만 발생한다.

B-트리는 리프 레벨부터 상향식으로 구성하기 때문에 리프 레벨을 먼저 구성하는 것이 가능하다.
즉, 상위 레벨을 구성하는 시점에서 모든 자식 포인터를 만들어둘 수 있다.
이 방식은 디스크에서 분할이나 병합할 필요가 없고 트리를 구성할 때 최소한의 부분만 메모리에 저장하면 된다는 장점이 있다.

불변 B-트리도 같은 방식으로 만들 수 있는데 수정이 불가능해 추가적인 공간 오버헤드가 발생하지 않고, 모든 페이지를 완전 채울 수 있으므로 점유율과 성능이 향상된다.

## 압축

원시 데이터를 압축하지 않고 저장하면 저장 오버헤드가 커진다. 그래서 대부분의 데이터베이스는 공간을 절약할 수 있는 압축 알고리즘을 제공한다.

압축 알고리즘에서 접근 속도와 압축률은 상반 관계다.
압축률이 높으면 데이터 크기가 감소하고, 한번에 많이 읽을 수 있지만 더 많은 RAM과 CPU 사이클을 사용한다.

데이터를 다양한 단위로 압축할 수 있다. 파일 전체를 압축하면 압축 효율은 올라가지만 업데이트시 파일 전체를 다시 압축해야 하므로 비효율적이다.
따라서 데이터셋이 클수록 작은 압축 단위가 적합하다.
인덱스 파일 또한 전체를 압축하는 것은 비효율적이다.

파일 전체가 아닌 페이지 단위로 압축하면 위에서 말한 문제를 해결할 수 있다.
고정 크기 페이지를 사용하므로 페이지 단위 압축을 사용하기에 좋고, 페이지 별로 독립적으로 압축, 압축 해제를 할 수 있으므로 페이지 로딩, 플러시를 같이 수행할 수 있다.

압축된 페이지의 크기는 디스크 블록 크기보다 작다.
데이터 전송은 블록 단위이므로 압축된 페이지가 블록의 극히 일부이면 비효율적인 상황이 생길 수도 있다.
![](files/Pasted%20image%2020230810211707.png)

데이터를 로우 단위, 칼럼 단위로 압축할 수도 있다. 하지만 이 경우 페이지 관리와 압축을 동시에 수행할 수는 없다.

## 정리와 유지

B-트리 유지를 위해서는 데이터 무결성 유지, 공간 회수, 오버헤드 최소화, 페이지 정렬 등 다양한 작업이 필요하다.
이러한 작업을 백그라운드에서 수행하면 시간을 절약할 수 있고, 삽입, 업데이트, 삭제 작업의 후처리 비용이 줄어든다.

슬롯 페이지 또한 추가적인 페이지 관리가 필요하다.
단편화가 발생하면 논리적인 공간은 충분하지만 물리적 공간이 부족해진다.
![](files/Pasted%20image%2020230810212203.png)
B-트리에서 접근할 수 있는 데이터를 라이브(live) 상태, 참조할 수 없는 데이터는 가비지(garbage) 상태라고 한다.
가비지 영역의 경우 어차피 새로운 데이터로 덮어쓸 것이기 때문에 해당 영역을 지우는 등의 동작은 불필요하다. 오히려 성능을 저하시킨다.

## 업데이트와 삭제로 인한 단편화

삭제된 리프 레벨의 셀은 헤더에서 오프셋만 제거하고 셀은 그대로 남겨둔다. 따라서 해당 셀은 더 이상 참조할 수 없다.
또한 페이지가 분할되면 페이지의 일부는 더 이상 참조할 수 없기 때문에 해당 오프셋은 삭제된다.

일부 데이터베이스는 삭제된, 업데이트된 셀을 바로 지우지 않고 멀티버전 동시성 제어(mvcc)를 위해 바로 삭제하지 않고 나중에 가비지 컬렉션을 수행한다.

삽입 작업은 튜플을 삽입 순서대로 저장한다. 큰 차이는 없지만 튜플을 **논리적 순서**로 저장하면 캐시를 프치패치해 **순차 읽기**에 도움을 줄 수 있다.

업데이트 작업은 대부분 리프 레벨에서 수행된다.
오버플로우 페이지 생성 외에는 트리의 구조를 변경하지 않는다.
리프 노드 업데이트 시 페이지 재구성을 최소화하기 위해 셀 순서는 변경하지 않는다.

## 페이지 단편화

공간 회수 및 페이지 재구성하는 과정을 **컴팩션**, **정리**, **유지보수**라고 한다.
페이지에 사용 가능한 물리적 공간이 부족한 경우 **오버플로우 페이지** 생성을 방지하기 위해서 컴팩션과 쓰기를 동시에 수행할 수도 있다.
하지만 일반적으로 **컴팩션**은 **페이지 별**로 가비지컬렉션을 수행하고, 데이터를 재작성하는 독립적인 비동기적 과정을 말한다.

컴팩션은 데드 셀이 차지하는 공간을 회수하고 셀을 **논리적 순서**로 재정렬한다.
재구성된 페이지는 파일에서의 위치가 변경될 수 있다.

사용 중이지 않은 인메모리 페이지는 페이지 캐시에 반환되며 디스크에 새로 할당된 페이지 ID는 프리 페이지 목록에 추가된다.
이러한 과정은 공간이 낭비되지 않도록 노드 장애나 재부팅 시에도 유지되어야 한다.


