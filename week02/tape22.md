# 3장 파일포맷


<br>



자료구조를 디스크에서 제어하는 방법에 대해 논의한다.

https://man7.org/linux/man-pages/man2/syscalls.2.html

디스크는 system call로 접근하며, 대상 파일 내의 오프셋을 직접 지정하고 메인 메모리에서 읽을 수 있는 형태로 변환해야한다.

> system call :https://man7.org/linux/man-pages/man2/syscalls.2.html
> is the fundamental interface between an application and the Linux kernel.

## 3-1. 파일 포맷의 중요성

- 데이터 블록을 할당하고, 고정크기의 기본형과 자료구조를 사용해 원하는 대로 잘라서 사용한다.
- 큰 메모리 chunk 또는 가변길이의 자료구조는 포인터를 사용하여 참조한다.

<br>

> 메모리 모델이 비관리형인 언어는 뭐가 있지? C, C++ <br>
> 동적할당 메모리를 수동으로 관리

- 메모리 데이터 레이아웃은 디스크보다 단순
    - 영속성 저장장치의 특성을 이해하고 빠르게 접근 가능한 형태로 저장해야하고,
    - 바이너리 포맷 구조 설계, 직렬/역직렬화 수단이 있어야함
- C언어와 같은 레벨언어에서 자료구조는 미리 정의된 크기를 갖고 명시적으로 할당/해제한다.
- 메인 메모리에 데이터를 저장하면, 레이아웃과 관련된 이슈는 발생하지 않거나 라이브러리로 해결 가능하다.

<br>

## 3-2. 바이너리 인코딩

- 디스크에 데이터를 효율적으로 저장하려면, 직렬화/역직렬화가 쉬운 포맷으로 인코딩해야한다.

    - 디스크에 저장된 데이터는 read/write만 가능
        - 접근 방식이 다르고 이에 맞는 형식으로 데이터를 저장해야함

### 3-2-1. 기본형

- integer, date, string 등 지정된 자료형
- 바이너리 형식 (직렬화/역직렬화)

숫자형은 대부분 고정 길이 자료형이고, 멀티 바이트 숫자형을 사용할 때는 같은 바이트 순서로 인코딩/디코딩해야한다.

- big endian : MSB(최상위 바이트)를 가장 낮은 주소로 -> 내림차순으로 저장
    - AA가 최상위 바이트인 16진수 32비트 정수형을 저장한다면? AA(MSB) BB CC DD ...
- little endian : LSM(최하위 바이트) -> 높은 자리까지 오름차순으로 저장
    - AA가 최상위 바이트인 16진수 32비트 정수형을 저장한다면? DD CC BB AA ...


** RocksDB는 대상 플랫폼의 바이트 순서를 알 수 있도록 정의가 포함되어있다.

- 레코드는 기본형(숫자, 문자열, 불리언)과 이들의 조합으로 구성됨
    - 바이트 시퀀스 형태로 네트워크를 통해 전송, 디스크에 저장
    - 전송 및 쓰기 전에 직렬화 -> 수신 및 읽기 전에 역직렬화가 필요

    - byte 8bit / short 2byte(16bit) / int 4byte(32) / long 8byte(64)

부동소수점은 부호, 가수, 지수로 구성된다.
- 32비트는 가수부, 8비트는 지수부, 마지막 1비트는 부호부(양,음)
- 가수를 사용하기 때문에 근삿값임

> 부동소수점 이슈 :


<br>

### 3-2-2. 문자열과 가변길이 데이터

> 고정길이 데이터 배열 ? :

문자열과 가변길이 자료형(고정 길이 데이터 배열)의 크기는
- 문자열의 길이를 나타내는 숫자와
- size 바이트 크기의 실제 데이터로 구성된다.

 ```
 String {
  size unit_16
  data byte[size]
 }
 ```


### 3-2-3. 비트 묶음형 데이터: 불리언, 열거형, 플래그


- boolean : 1, 0 / 8bit -> 각 1비트씩 불리언 값을 묶어서 쓰기도 한다. (packed)
- Enum : 가짓수가 적고 반복해서 나오는 값을 표현할 때 사용
- flag : packed boolean + enum / 모든 비트가 플래그여서 2의 거듭제곱만 지정 가능
    - 페이지 값 보유여부, 특정 값 크기나 페이지 오버플로우 여부 등
    - (예) int IS_LEAF_MASK = 0x01h

## 3-3. 파일 포맷 설계원칙

파일포맷을 설계할 때 주소 지정 방식부터 결정해야한다.

- 인플레이스 업데이트 방식을 지원하는 자료구조는 고정된 페이지 크기를 사용
    - 읽기쓰기가 비교적 쉽기 때문

- 추가전용 자료구조도 페이지 단위로 쓰고, 레코드를 순차적으로 추가한 다음 / 페이지가 가득차면 디스크로 플러시한다.

- 파일은 header로 시작해서 - 끝엔 trailer(빠르게 접근하거나 디코딩에 필요한 보조정보)가 있다.

<br>

## 3-4. 페이지 구조

- DB 시스템은 데이터 레코드를 데이터 파일과 인덱스 파일에 저장한다.
    - 파일은 여러 파일 시스템 블록을 합친 고정 크기의 페이지로 구성
    - 블록 크기는 4kb ~ 16kb 로 다양


> B-Tree 노드는 단일 페이지, 또는 연결된 페이지들로 구성된다. (노드 == 페이지)

=> 가변 길이 레코드를 효율적으로 저장하거나 관리하기 어렵다.
=> 빈 공간이 아닌 곳에 키를 추가하려면 여러 원소들을 재배치해야한다.

<br>

## 3-5. 슬롯 페이지

가변 길이 레코드를 저장할 때 가장 큰 문제점은 *삭제된 레코드 공간을 회수*하는 공간관리다.

- 길이 m 레코드 위치에 n을 저장하려고 할 때
- m == n이 아니면 이 공간을 최대한 활용하려면 m - n인 또 다른 레코드가 필요하다.
- k가 m보다 큰 경우 길이가 m인 세그먼트에 k인 레코드를 저장할 수 없다.



페이지를 여러 개의 고정길이 세그먼트로 분할하면 가변 길이 레코드를 저장할 수 있지만, 공간 낭비를 피할 수는 없다.

- 세그먼트 크기가 64byte일 때, 레코드 길이가 64의 배수가 아니면 일부는 비어있게 됨

> 그러면 가장 괜찮은 방법은 무엇인가

그래서 공간 회수 시 페이지를 재작성하고, 일부 레코드를 재배치한다. 다만 다른 페이지에서 재배치 된 데이터를 참조할 수 있으니, 레코드의 오프셋은 유지한다.

페이지 포맷 조건

- 1. 최소한의 오버헤드로 가변 길이 레코드 저장
- 2. 삭제된 레코드 메모리 회수
- 3. 페이지 레코드를 정확한 위치와 상관없이 참조


> PostgreSQL은 슬롯 페이지를 사용해서 문자열, blob 같은 가변길이 자료형을 효율적으로 저장한다.
> 다른 DB들은 어떻게 가변길이 자료형을 관리하는가?
> 가변길이 자료형에는 뭐가 있지?


페이지 =>  슬롯 또는 셀의 집합
레코드는 논리적인 순서는 셀을 가리키는 포인터 순서로 제어하고, 레코드 삭제 시 해당 포인터를 삭제/ null로 둔다.

슬롯 페이지는 페이지 포맷 조건을 모두 충족한다.

- 1. 오버헤드 최소화 : 실제 레코드 위치를 가리키는 포인터 배열 사용이 유일한 오버헤드
- 2. 공간 회수 : 단편화 제거 및 페이지 재구성을 통해 공간을 회수
- 3. 동적 레이아웃 : ID를 통해 페이지 외부에서 접근하기 때문에 정확한 위치는 페이지 내부에만 필요

> https://www.cubrid.com/blog/3822789#:~:text=슬랏%20페이지%20구조란%20이런,데이터가%20쓰여지게%20된다.

## 3-6. 셀 구조

flag, enum, 기본형으로 셀 레이아웃을 설계할 수 있다.

- 셀 -> 페이지 -> 트리
- key 셀과 key:value 셀로 구분
    - key 셀: 구분 키와 인접한 페이지를 가리키는 포인터
        - 셀 종류 / 키 길이 / 셀이 가리키는 자식 페이지의 ID / 키 바이트 수
        - [int] key size / [int] page_id / [bytes] key
    - key:value 셀 ;: 키와 해당 데이터 레코드
        - 셀 종류 / 키 길이 / 값 길이 / 키 바이트 / 데이터 레코드 바이트
        - [byte] flags / [int] key size / [int] value size / [byte] key / [bytes] data_record


- 한 페이지에 모든 셀이 동일한 형식이면, 셀에 관한 정보를 중복저장하지 않고 페이지 레벨에서 저장해도된다. -> 무슨 말?

<br>

## 3-7. 셀 병합으로 슬롯 페이지 구성

슬롯 페이지 방식을 사용하면 셀을 병합해서 페이지를 구성할 수 있다.

페이지의 셀은 오른쪽에 추가하고, 셀 오프셋/포인터는 왼쪽에 추가해보자.
- 키는 삽입 순서대로 추가하고, 셀 오프셋 포인터는 키 순서대로 저장하면 논리적 순서를 유지할 수 있음
- 셀을 CUD 해도 다른 셀을 재배치하도 않아도 되는 장점이 있다.

<br>

## 3-8. 가변 길이 데이터 관리

페이지 레코드를 삭제할 때, 실제 셀을 지우고 할당 해제된 다른 공간으로 셀을 옮길 필요는 없다.

- 삭제된 셀로 표시하고
- 사용가능목록에 회수된 메모리 크기와 포인터를 업데이트해도 된다.
    - 사용할 수 있는 세그먼트 크기와 위치가 저장됨
    - 새로운 셀을 삽입하기 전에 해당 목록에 적합한 세그먼트가 있는지 확인한다.

> SQLite는 사용 중이지 않은 세그먼트를 freeblock이라고 부르고, 첫 번째 프리블록 포인터를 페이지 헤더에 저장한다.

세그먼트는 두 가지 전략에 따라 선택할 수 있다.

- First fit
    - 첫 번째로 찾은 적합한 세그먼트를 선택
    - 남은 공간이 또 다른 셀을 저장해서 크기가 작을 수 있어서 오버헤드 발생

- Best fit
    - 레코드를 저장할 수 있는 가장 작은 세그먼트 선택

단편화된 부분의 집합 크기가 충분하면, 셀을 읽고 재배치해서 페이지 단편화를 제거하면
새로운 셀을 연속된 공간에 저장할 수 있다. -> 그래도 부족하면 오버플로우 페이지를 생성

<br>


## 3-9. 버전관리

데이터베이스는 신규 기능 추가, 버그 수정, 성능 개선 등 업데이트를 하면서 *바이너리 파일 구조*가 변경될 수 있다.

직렬화 포맷 또한 달라지기 때문에 파일 버전 관리는 중요하다.

> mysql? <br>
> 아파치 카산드라는 파일명 접두사에 버전을 기록한다. (na ~ ma ~) <br>
> PostgreSQL은 PG_VERSION 이라는 개별파일에 버전 정보를 기록한다. <br>
> 인덱스 파일 헤더에 버전을 명시하기도 한다 -> 어떤 DB가?

## 3-10. 체크섬

디스크에 저장된 파일은 어떤 이유든 손상될 수 있다. 이를 사전에 파악하고 손상된 데이터의 전파를 방지하기 위해 *체크섬*과 *CRC(Cyclic Redundancy Check)* 를 사용한다.

- 체크섬은 보장성이 매우 낮고, 다중비트 오류는 감지하지 못함.
- CRC는 버스트 오류를 감지할 수 없다.

데이터를 디스크에 쓰기 전, 체크섬을 미리 계산하고 데이터와 함께 저장한다. <br>
-> 데이터 요청이 들어오면 체크섬을 계산해서 저장된 체크섬과 비교한다. <br>
-> 일치하지 않으면 데이터 손상 <br>
-> 모든 파일에 대해 검사하기보다, 페이지 단위로 계산하고 페이지 헤더에 저장한다.

<br>



# 4장 B-Tree 구현


키와 포인터의 관계를 정의하고, 페이지를 연결하는 헤더/링크를 구현하는 방법

## 4-1. 페이지 헤더

- 페이지 헤더에는 탐색, 유지보수, 최적화에 필요한 정보를 저장
    - 메타데이터를 저장 : 플래그, 레이아웃, 셀 개수 등
    - 예: postgreSQL은 페이지 크기와 레이아웃 버전을 저장
        - Mysql InnoDB는 힙 레코드 개수와 레벨, 기타 구조와 관련된 값을 저장
        - SQLite 는 셀 개수와 가장 오른쪽 포인터를 저장



### 매직넘버

- 상수 값을 포함하는 멀티바이트 블록이며, 페이지 종류와 버전과 같은 정보
    - 검증과 상태 체크에도 사용된다.
    - 페이지를 읽고 쓸 때 특정 값을 헤더에 저장하고, 읽을 때 헤더의 4바이트 값과 비교하여 일치하는지 검증한다.

> 파일 시그니처 예: PNG 89 50 4E 47 0D 0A 1A 0A
> <br> 파일이 갖고 있는 포맷을 식별하기 위한 값


### 형제링크

-  좌우에 있는 형제 페이지를 가리키도록 순방향/역방향 링크를 저장하는 방식
    - 부모노드로 거슬러 올라가지 않고 이웃 노드를 참조할 수 있다.
    - but 분할/병합 시 이웃 오프셋까지 갱신해야함.


### 가장 오른쪽 포인터

B-Tree의 구분 키 주 역할은 트리를 서브트리로 분할하고 탐색할 수 있도록 하는 것

- 자식 페이지를 가리키는 포인터가 하나 더 있다. (N+1)
- 각 구분 키에는 자식 포인터가 있고, 마지막은 어느 키와 연관되지 않아 별도로 저장
- 가장 오른쪽 자식노드가 *분할되고, 부모에 새로운 셀이 추가되면 부모의 마지막 포인터도 재설정이 필요*


### 하이 키

현재 노드의 서브트리에 저장된 가장 큰 키. (B link Tree)

- 각 노드에 키 하나를 더 추가해서 Pn이 가리키는 하이키를 나타낸다.
- 각 노드에 저장된 키와 포인터 개수가 같으며, 모든 셀에는 키-포인터 쌍이 존재하게된다.



### 오버플로우 페이지

- 노드의 크기와 트리 팬아웃은 고정값
- B-Tree 알고리즘에서 모든 노드는 일정 개수의 키를 유지해야함.
- 4K 페이지에 삽입된 값이 더 크면, 4K 단위로 노드를 확장하고 새로운 페이지를 원본 페이지에 연결한다.
    - 그렇게 되면 크기를 추가확장하지 않아도 된다.
- 대부분은 고정 크기 바이트만 노드에 저장하고, 나머지는 오버플로우 페이지에 저장
  (고정 크기 = 노드 크기 / 팬아웃(최대자식노드수))

> https://dev.mysql.com/doc/refman/8.0/en/innodb-file-space.html <br>
> COMPACT and REDUNDANT Row Formats > When a variable-length column is chosen for external off-page storage, InnoDB stores the first 768 bytes locally in the row, and the rest externally into overflow pages. Each such column has its own list of overflow pages.



---

## 4-2. 이진검색 (Binary Search)

> 루트 노드 -> 리프 노드까지 순회하는 과정
> - 이진탐색 알고리즘에서 탐색 경로를 결정하는 방법
> - 노드 분할 및 병합 시 부모노드 정보를 참조하는 방법


이진 검색은 정렬된 데이터에만 유효하다.

- 정렬된 배열과 검색 키를 인자로 받아서 숫자를 반환
    - 숫자가 양수면 존재하는 키, 배열의 위치
    - 음수라면 존재하지 않는 키, 삽입의 위치


### 간접 포인터를 사용한 이진탐색

- 페이지 셀은 삽입 순서대로 저장되고, 오프셋만 논리적 순서를 유지한다.
- 중간 셀 오프셋을 선택해서 왼/오 진행방향 결정

### 분할과 병합

- 형제 포인터를 사용하면 발생할 수 있는 데드락을 제거하기 위해 부모 포인터를 사용하기도 함.(wiredTiger : MongoDB에서 쓰는 엔진이네)
    - 부모 노드 -> 형제 노드 찾아서 순회한다음 -> 상위레벨로 올라가면서 검색

### 탐색 경로

- 리프 노드까지의 경로를 저장하고, 분할 및 병합이 발생하면 해당 경로를 역순으로 조회할 수도 있음
    - 탐색 경로는 루트부터 방문한 모든 노드에 대한 정보를 포함한다.
    - 트리 구조 변경하려면 순회해야하는데, 리프노드에 도달하기 전까지 분할/병합 여부를 미리 알 수 없기 때문에 저장한다.
    - 경로를 저장한 스택은 메모리에 유지한다.


----

### 리밸런싱
> 분할과 병합 횟수를 줄이기 위해 이웃 노드로 요소를 일부 이동하는 방법 <br>
> 리밸런싱 비용이 높아질 수 있지만 노드 점유율을 높이고, 트리 높이를 낮출 수 있다.

- B-Tree 는 형제 노드가 모두 가득찰 때까지 이웃 노드 간에 원소를 분산
    - SQLite -> 두 노드를 3분의2로 채워진 3개 노드로 분할
    - 트리 높이가 낮아지고 순회 시 참조하는 페이지 수가 줄어들면 검색 효율도 높아짐


### 오른쪽 추가 기법
> 새로운 데이터를 빠르게 삽입할 때는 셀을 분할하기 보다 트리 가장 오른쪽 셀에 데이터 추가

- 대다수의 DB가 auto increament 를 기본 인덱스 키로 설정
- 모든 insert가 가장 오른쪽 리프인 인덱스 끝에서만 발생해서, 각 레벨의 가장 오른쪽 노드에서만 노드분할 작업이 대부분 일어나게 된다.

postgreSQL fastpath / SQLite quickbalance

    **  벌크로딩
    정렬된 데이터를 사용해 가장 오른쪽에만 데이터를 추가하면 됨.
    리프 레벨에 정렬된 데이터를 페이지 단위로 저장하는 방식으로 구현가능

### 압축

압축률이 높을수록 데이터 크기는 작아져서 한 번에 많이 읽을 수 있지만, 해제 작업에서 더 많은 리소스를 사용하게 된다.

- 파일 단위로 압축하거나, 페이지 단위로 압축하는 방법, 로우나 컬럼 단위로 압축하는 방법
    - 데이터 전송이 블록 단위여서 비효율적일 수 있다.
    - 압축된 페이지가 블록 일부분만 차지하는 경우 실제보다 더 많이 읽어야함.

### 업데이트와 삭제로 인한 단편화

> 가비지 데이터가 있는 페이지를 compaction 하는 방법?

- 삭제된 리프레벨 셀은 헤더에서 오프셋만 제거하고 실제 셀은 남겨두기
    - 셀이 참조될 수 없어서 쿼리 대상에서 제외
    - 남은 셀은 새 데이터로 덮어쓰거나 정리 단계에서 GC가 처리

*fragmentation* : 사용 가능한 바이트가 페이지에 흩어져있는 현상. 물리적으로 셀을 삭제하지 않고 오프셋만 삭제하면서 발생할 수 있음.

- 데이터를 저장하려면 연속된 바이트 블록이 필요한데, 단편화되어있으면 재구성이 필요하다.


### 페이지 단편화

유지보수-. 즉 compaction은 공간 회수 및 페이지를 재구성하는 과정을 말한다. <br>
페이지 별로 GC를 수행하고, 데이터를 재작성하는 독립적인 비동기 과정

- 데드셀이 차지하는 공간을 회수
- 셀을 논리적 순서로 재정렬