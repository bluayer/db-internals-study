## 들어가며
애플리케이션 : 로직과 사용자 인터페이스 제공
데이터베이스 : 데이터의 **무결성**, **일관성**을 보장. 데이터를 **이중화**

2000년만 해도 데이터베이스 종류는 다양하지 않았다. 대부분 관계형 데이터베이스였으며, 시스템 간의 차이도 크지 않았다.
당시에는 오히려 **수평 확장성(Horizontal scaling, scale out)** 에 집중했다. 
- 수평 확장 (scale out)
	- 여러 데이터베이스 인스턴스를 **하나의 논리적 인스턴스**로 결합하는 방식
	- 새로운 인스턴스를 추가해 시스템의 **성능**과 **용량**을 올릴 수 있다
- 수직 확장 (scale up)
	- 더 좋은 머신으로 교체하는 방식
	- 머신을 교체하는 과정에서 **마이그레이션**이 필요하며, **다운 타임**에 대한 고려가 필요하다

그에 대한 예시로 그린플럼(Greenplum)이 있었다. 홈페이지에 가보면 Greenplum DB를 다음과 같이 소개하고 있다.

> 세계 최초의 오픈소스 & MPP 데이터 플랫폼 (The World's First Open-Source & Massively Parallel Data Platform)

**MPP**는 **Massively Parallel Processing**의 약자로 **Shared Nothing Architecture**라고도 한다. 여러 개의 디스크, 여러 개의 CPU를 네트워크를 통해 추가해 나가면서 확장할 수 있는 구조를 말한다.

2010년부터는 결과적 **일관성 모델**을 기반으로 하는 데이터베이스가 등장헀다.
그에 따라 **NoSQL**이나 **빅데이터**와 같은 용어도 유행했다.
그에 따라 수많은 데이터베이스와 관련 툴이 개발되기 시작했다.

2007년에 발표된 아마존의 다이나모 논문([원문](https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.115.1568&rep=rep1&type=pdf), [번역본](https://parksb.github.io/papers-i-love/dynamo-amazons-highly-available-key-value-store.html))은 많은 파장을 일으켰고, 그에 따른 다양한 변형 시스템이 등장했다.
- [Apache Cassandra](https://cassandra.apache.org/_/index.html)
- [Project Voldemort](https://www.project-voldemort.com/voldemort/)
- [Riak](https://riak.com/index.html)

데이터베이스 분야는 계속 변화하고 있다. 관계형 데이터베이스 모델에 이어서 키-값 스토어, NoSQL, 결과적 일관성 모델 이후 더 높은 **확장성**과 **성능**을 제공하면서 **복잡한 쿼리**를 수행하고, **강력한 일관성**을 보장하는 데이터베이스가 나오고 있다.

## 1부 스토리지 엔진
데이터베이스 관리 시스템(DBMS, Database Management System)의 주목적은 **데이터**를 **안정적**으로 **저장**하고 사용자에게 **제공**하는 것

데이터베이스는 모듈식 시스템
- 전송 계층 : 요청을 전달
- 쿼리 프로세서 : 가장 효율적인 쿼리 실행 계획 결정
- 실행 엔진 : 실제 작업 수행
- 스토리지 엔진
	- 데이터를 **메모리** or **디스크**에 저장
	- 데이터를 검색 및 관리하는 소프트웨어
	- 각 **노드**에 데이터를 **영구 저장**
	- 복잡한 쿼리 수행을 위해 데이터를 세밀하게 조작할 수 있는 **API** 제공
		- 사용자는 이를 통해 레코드 생성, 업데이트, 삭제, 검색

데이터를 **키-값 형식**으로 저장한다고 했을 때, **유연성**을 위해 키와 값은 모두 **임의의 바이트 시퀀스**가 될 수 있다.
즉, 이들의 순서나 **표현 방식**은 **상위 레벨 서브시스템**에서 정의한다.
이 덕분에 키를 `int32`로도 저장할 수 있고 `ascii` 코드로도 저장할 수 있다.
스토리지 엔진 입장에서는 모두 **직렬화된 바이트 값**일 뿐이다.

또한 경우에 따라서 **스토리지 엔진**이 **DBMS**와 **독립적**으로 개발되는 경우도 있다. 이 경우 개발자는 플러그형 형태의 스토리지 엔진을 사용하면 되기 때문에 다른 서브시스템 개발에 집중할 수 있다.
또한 데이터베이스의 시스템 컴포넌트를 명확히 분리하면 이에 맞는 스토리지 엔진을 맞춰서 사용하는 것도 가능하다.

### 데이터베이스 비교
데이터베이스는 교체가 어렵기 때문에 신중하게 선택해야 한다.
모든 데이터베이스 시스템에는 장단점이 있다. 따라서 충분한 시간을 들여서 요구사항을 충족하는 데이터베이스를 선택할 수 있어야 한다.

컴포넌트(사용하는 스토리지 엔진 종류, 데이터를 공유, 복사 및 저장하는 방법 등), 순위, 지원하는 언어 등을 기준으로 데이터베이스를 비교하는 것은 올바르지 않을 수 있다. 이는 HBase나 SQLite의 비교와 같이 상위 개념의 비교에 더 적합하다.
데이터베이스의 작동 방식이나 내부 구조에 대한 사소한 지식이 오히려 선택에 더 도움이 될 수도 있다.

데이터베이스 비교 전에 꼭 목표를 명확하게 설정해야 한다. 데이터베이스에 대한 작은 편견이 결정을 바꿀 수 있으므로 명확한 목표가 필요하다.
또한 성능이나 확장성 관련 문제는 시간이 흐르거나, 사용량이 늘어났을 때 발생하므로 잠재적인 문제 또한 충분히 오랫동안 고려하고 테스트해봐야 한다.

데이터베이스를 선택할 때는 여러 요소를 고려해야 하며, 성능이 최우선 요소가 아닐 수도 있다. 데이터가 손실되는 데이터베이스보다는 느리지만 데이터가 보존되는 데이터베이스가 더 유용하다.

데이터베이스를 비교하기 위해서 **사용 목적**을 구체적으로 파악하고 난 뒤에는 다음 변수를 미리 정의하고 예측해야 한다.
- 스키마와 레코드 크기
- 클라이언트 수
- 쿼리 형식과 접근 패턴
- 읽기와 쓰기 쿼리 비율
- 위 변수들의 **변동폭**

위 변수들을 정의하고 나면 아래와 같은 질문에 답변할 수 있다.
- 요청된 쿼리를 수행할 수 있는가?
- 데이터를 모두 저장할 수 있는가?
- 단일 노드는 몇 건의 읽기와 쓰기 요청을 처리할 수 있는가?
- 시스템에는 몇 개의 노드가 필요한가?
- 데이터 증가 추세에 맞춰 클러스터를 확장할 수 있는가?
- 유지보수는 어떻게 할 것인가?

위 질문에 답할 수 있다면 워크로드를 시뮬레이션하면 된다.

> 야후 클라우드 서빙 벤치마크(YCSB)와 같은 대표적인 벤치마킹 및 성능 측정 툴이다.
> 하지만 보편적인 툴은 잘못된 결론을 도출할 수 있기 때문에 주의해서 사용해야 한다.

테스트 결과가 긍정적이라면 소스코드를 분석하는 것도 도움이 된다. 소스 코드를 대략 파악해두면 데이터베이스가 생성하는 **로그**와 **시스템 설정** 값의 의미를 더 잘 이해할 수 있고, 데이터베이스 자체의 문제를 찾는 데에도 도움이 된다.

> TPC는 데이터베이스에 대한 여러 벤치마크를 제공한다.
> TPC_C는 OLTP 벤치마크로서 일반적인 애플리케이션의 워크로드를 시뮬레이션할 수 있다. 읽기 전용 트랜잭션과 업데이트 트랜잭션으로 구성되어 있다.
> TPC-C는 **동시 수행 트랜잭션의 성능**과 **정확성**을 평가한다. 
> 이는 OLTP 애플리케이션의 작업 패턴을 흉내낸 것으로 모든 비즈니스의 워크로드를 흉내낼 수 있는 것은 아니다.

또한 데이터베이스의 사용은 장기적이므로 최신 동향을 살펴보는 것도 좋다. 최신 버전에서 어떠한 것이 변경되었고, 왜 변경되었는지를 파악해두면 좋다. 데이터베이스 개발 업체가 지금까지 해온 업데이트 방향을 따라갈 확률이 높기 때문에 미리 파악해두면 데이터베이스 결정에 도움이 될 수 있다.

### 장단점 비교
데이터베이스의 **스토리지 엔진**을 설계하는 일은 매우 복잡하다. 결정해야 할 사항들이 매우 많으며 대부분이 **절충적**이다.
- 물리적 데이터 레이아웃 설계와 포인터 관리
- 직렬화 방식 및 데이터 가비지 컬렉션 방식 정의
- 데이터베이스 시스템의 시맨틱에 맞는 스토리지 엔진 구현
- 동시성 지원

예를 들어 레코드를 삽입 순서대로 저장하면 저장 성능을 높일 순 있지만 사전순으로 검색할 경우 재정렬이 필요하다. 즉, 스토리지 엔진을 설계하는 과정에 있어서 다양한 선택을 내릴 수 있으며 각 방식마다 **장단점**이 있다.
따라서 스토리지 엔진을 비교할 때 장단점을 모두 살펴봐야 한다. 워크로드에 최적인 스토리지 엔진이 있으면 좋겠지만 현실적으로 그렇지 않으므로 신중하게 결정해야 한다.

스토리지 엔진 설계에 따라서 **읽기와 쓰기 레이턴시를 최소화**하거나, **저장량**(노드별로 저장된 데이터의 양)을 **극대화**하며, **유지관리를 간소화**한다.

## 1장 소개 및 개요
데이터베이스의 용도는 다양하다.
- 일시적힌 핫 데이터를 저장 vs 장기 보관용 콜드 데이터 저장
- 복잡한 쿼리 분석 vs 키로만 값 액세스
- 시계열 데이터 저장에 최적 vs blob 데이터 저장에 효율적

### DBMS 구조
표준화된 DBMS 구조는 존재하지 않는다. 구조도 다 다르고 컴포넌트 경계도 다 다르다. 또한 성능 최적화나 에지 케이스 처리, 혹은 설계적 이유에 의해서 컴포넌트를 결합하기도 한다.
다만, 다음과 같은 대략적인 공통 정의를 뽑아내 볼 수는 있다.
![](files/Pasted%20image%2020230802172238.png)
DBMS는 **클라이언트/서버 모델**을 기반으로 한다.
- 서버 : 데이터베이스 인스턴스(노드)
- 클라이언트 : 애플리케이션 인스턴스

클라이언트의 요청은 **트랜스포트 서브시스템**을 통해 전달된다. 요청은 쿼리 형태이며, 주로 특정 쿼리 언어를 사용한다.
트랜스포트 서브시스템은 데이터베이스 **클러스터 노드 사이의 통신**에도 사용된다.

트랜스포트 서브시스템은 쿼리를 **쿼리 프로세서**에게 전달한다. 
쿼리 프로세서는 쿼리를 **해석**, **분석** 및 **검증**한다.
쿼리의 의미를 파악하고 나면 **액세스 제어**를 진행할 수 있다.

분석된 쿼리는 **쿼리 옵티마이저**에게 전달된다. 쿼리에서 논리적으로 불가능한 부분과 중복을 제거하고 나면 다음을 참고해 가장 효율적인 **쿼리 실행 계획**을 생성한다.
- 내부 데이터 통계(인덱스 카디널리티와 교집합 크기 등)
- 데이터 위치(클러스터 내 데이터 저장 위치와 전송 비용)

이 과정에서 쿼리 수행에 필요한 **관계형 연산**을 **종속 트리(dependency tree)** 로 변환하며, **인덱스 순서 선택**, **카디널리티 예측**, **액세스 메소드 선택** 등의 최적화 작업을 진행한다.

쿼리는 일반적으로 **실행 계획(execution plan)** 형태로 표현하는데 같은 쿼리라도 여러 실행 계획이 존재할 수 있으며, 옵티마이저는 가장 효율적인 계획을 선택한다.
> 실행 계획 : 쿼리가 요구하는 결과를 도출하기 위한 일련의 작업

이렇게 선택된 실행 계획은 **실행 엔진**이 수행한다. 실행 엔진은 로컬 실행, 원격 실행을 수행하고, 이를 결합한다.
- 로컬 실행(로컬 쿼리)
	- 클라이언트 혹은 다른 노드가 요청한다
	- 스토리지 엔진이 수행한다
- 원격 실행 : 클러스터 내 여러 **노드** 사이의 데이터 **읽기**, **쓰기** 및 **복제** 등

스토리지 엔진은 다음으로 구성된다.
- 트랜잭션 매니저 : 트랜잭션 스케줄링, 논리적 일관성 보장
- 잠금 매니저 : 트랜잭션에서 접근하는 객체에 대한 잠금 제어, 동시 작업이 물리적 데이터 무결성을 해치치 않도록 제어
- 액세스 메소드 : 디스크에 저장된 데이터 접근 및 저장 방식을 정의
- 버퍼 매니저 : 데이터 페이지를 메모리에 캐시
- 복구 매니저 : 로그 유지 관리, 장애 발생 시 시스템 복구

**트랜잭션 매니저**와 **잠금 매니저**는 **동시성**을 제어한다.
논리적, 물리적 **데이터 무결성**을 보장하고 **동시 작업**의 **효율적인 수행**을 담당한다.
즉, **무결성**을 보장하면서 최대한의 **성능**을 챙긴다.

### 인메모리 DBMS 대 디스크 기반 DBMS
DBMS는 **데이터**를 **메모리**와 **디스크**에 저장한다.

- 인메모리 DBMS
	- 메모리에 데이터 저장
	- 디스크는 복구, 로그 저장 용도
- 디스크 기반 DBMS 
	- 대부분의 데이터를 디스크에 저장
	- 메모리는 캐시, 임시 저장 용도로 사용

메모리는 디스크보다 훨씬 빠르게 데이터에 접근할 수 있으므로 메모리를 기본 스토리지로 사용하는 것이 더 효율적이다. 메모리 가격이 하락하면 현실적으로 타당하지면 여전히 HDD와 SDD가 훨씬 싸다.

**인메모리 DB**는 **디스크 기반 DB**와 **기본 저장 매체**도 다르지만 **내부 자료 구조**와 **설계**, **최적화 방식** 모두 다르다.
> 인메모리 DBMS는 디스크기반 DBMS에 비해서 직렬화, 데이터 레이아웃 유지 오버헤드가 없어서 성능이 더 좋을 수밖에 없다.

메모리를 주 저장 매체로 사용하는 이유는 다음과 같다.
- 성능
- 상대적으로 낮은 데이터 접근 비용
- 세밀한 접근 단위
	- 메모리 제어가 디스크 제어보다 프로그래밍적으로 더 간단하다.
		- OS의 메모리 추상화를 통해 편하게 메모리를 할당받고, 해제할 수 있다
		- 하지만 디스크는 데이터 참조, 직렬화 포맷 설정, 메모리 해제, 메모리 단편화 등의 이슈가 있다
			- 여기서 메모리는 디스크의 저장된 공간을 의미하는 것인지..?

하지만 메모리의 가장 큰 단점은 RAM의 휘발성과 가격이다. RAM에 저장된 데이터는 영구적이지 않으므로 데이터가 손실될 수 있다.
추가적인 하드웨어나 관리를 통해 이를 완화할 순 있지만 디스크가 유지관리 측면에서 훨씬 간단하고 비용이 낮은 것은 분명하다.

비휘발성 램(NVM)이 더 대중화된다면 상황이 바뀔 것이다.
읽기, 쓰기 레이턴시의 불균형도 줄어들고, 읽기 쓰기 성능도 더 좋고, 바이트 주소로 메모리에 바로 접근할 수 있으면서도 데이터 손실이 없는 스토리지가 될 수 있다.

### 인메모리 데이터베이스의 지속성
인메모리 DBMS는 **데이터의 지속성**을 보장, 손실을 막기 위해 **데이터**를 **디스크**에 **백업**한다.
> 지속성을 보장하지 않고 모든 데이터를 메모리에 저장하는 경우도 있긴 하다.

모든 작업은 **로그 파일**에 **작업 내용**을 **순차적**으로 기록해야 완료된다.
> **선행 기록 로그(write-ahead log)**

또한 매번 모든 **로그**를 재수행 할 수는 없으므로 **백업본**을 유지한다. 백업본은 **디스크 기반 자료구조**에 **순서대로** 저장한다.
이 내용은 보통 **비동기적**으로 갱신하며, **I/O**를 최소화하기 위해서 **배치 단위**로 백업한다.
데이터 복구 시 **백업본**과 **로그** 기반으로 데이터를 재구성한다.
**로그**의 배치 단위의 백업이 완료되면 **백업본**은 특정 시점의 DB **스냅숏**이 된다. 따라서 스냅숏 이전의 로그는 삭제해도 된다.
이를 **체크포인트**를 남긴다고 표현한다.
클라이언트의 요청을 **블록**하지 않고 백업본을 최신 로그와 동기화하면 복구 시 **소요 시간**을 줄일 수 있다.

디스크 기반 DBMS는 **디스크 접근에 특화된 자료 구조**를 사용한다. 
- 메모리는 포인터를 사용해 비교적으로 디스크보다 빠르게 참조가 가능하다.
- 랜덤 메모리 접근 속도는 랜덤 디스크 접근 속도보다 훨씬 빠르다.
- 디스크 기반 자료구조는 넓고 낮은 트리지만 인메모리 자료 구조는 다양한 형태가 존재한다.
- 인메모리는 디스크에서는 불가능하거나, 어려운 방식의 최적화를 할 수도 있다.
- 디스크는 가변 크기의 데이터 제어가 복잡하지만, 메모리는 포인터를 사용해 쉽게 가능하다

일반적으로 레코드의 크기나, 레코드의 수도 그리 크지 않기 때문에 데이터 전체를 메모리에 저장할 수 있다고 가정해도 된다.

### 칼럼형 DBMS 대 로우형 DBMS
대부분의 DBMS는 **열**과 **행**으로 구성된 **테이블** 형태로 데이터를 저장한다.
**필드**는 **행**과 **열**의 교차점이며 특정 자료형의 **단일 값**이다.

데이터를 테이블에 저장하는 형태에 따라서 **칼럼 저장 방식**, **로우 저장 방식**으로 나눌 수 있다.
- 칼럼 저장 방식 : 테이블을 수직 분할 (같은 칼럼에 속하는 값을 같이 저장)
- 로우 저장 방식 : 테이블을 수평 분할 (같은 로우에 속하는 값을 같이 저장)

![](files/Pasted%20image%2020230803121639.png)

### 로우형 데이터 레이아웃
로우형 DBMS는 데이터 레코드를 로우 형식으로 저장한다.
이 방식은 **고유 식별 키**로 여러 필드를 구분할 수 있는 경우에 적합하다.
특정 사용자의 모든 필드는 일반적으로 함께 요청되며, 레코드를 생성할 때도 모든 필드를 함께 쓴다.
또한 각 레코드의 필드를 개별적으로 수정하기도 한다.

따라서 로우형 DBMS는 **한 개의 로우**씩 접근하는 경우 적합하다.
이 경우 **공간지역성**을 극대화할 수 있다.

디스크의 데이터는 **블록 단위**로 접근하기 때문에 한 블록에 모든 칼럼의 값을 저장한다.
따라서 특정 사용자의 모든 필드를 읽을 때는 **효율적**이지만, 여러 사용자의 특정 필드를 읽을 때는 반대로 **비효율적**이다.
필요없는 필드까지 페이징하기 때문이다.

### 칼럼형 데이터 레이아웃
칼럼형 DBMS는 데이터 레코드를 **칼럼 단위**로 저장한다.
즉, **로우**를 연속해서 저장하는 것이 아니라 같은 **칼럼**끼리 디스크에 연속해서 저장한다.
칼럼 별로 다른 파일, 혹은 세그먼트에 저장하면 효율적으로 데이터를 칼럼 단위로 읽을 수 있다.
로우형 DBMS와 달리 필요없는 필드를 읽을 필요가 없다.

따라서 칼럼형 DBMS는 **집계 분석 작업**에 적합하다.

그러나 칼럼형 DBMS에서는 **조인**과 **필터링**, **다중 로우 집계** 등을 위해 튜플을 재구성하려면 **칼럼 사이의 관계**를 나타내는 **추가적인 메타데이터**가 필요하다.
따라서 각 값마다 **중복된 키**가 존재하고, 데이터의 양이 증가한다.

일부 칼럼형 DBMS는 **가상 식별자**를 저장하고, **값의 위치(오프셋)** 을 기반으로 튜플을 재구성한다.
> 가상 식별자와 관련된 내용을 찾을 수 없었는데 무엇일지

### 차이점과 최적화 기법
로우형 DBMS와 칼럼형 DBMS의 데이터 저장 방법이 다른 것은 맞지만, 다른 차이점들도 존재한다.
데이터 레이아웃은 칼럼형 DBMS가 사용한 최적화 방법 중 하나일 뿐이다.

같은 칼럼의 여러 값을 한 번에 읽으면 **캐시 활용도**나 **처리 효율성**이 높아진다.
최신 CPU는 **벡터 연산**으로 한 번에 많은 데이터를 처리할 수 있다.

자료형별로 저장하면 압축률도 증가한다. 다양한 압축 알고리즘 중에서 자료형에 잘 맞는 압축 알고리즘을 선택할 수도 있다.
> 로우형과 달리 칼럼형은 중복되는 값이 훨씬 많기 떄문에 압축 효율이 높다는 이야기도 있었다.

하지만 로우형, 칼럼형 모두 장단점이 있기 때문에 **액세스 패턴**을 잘 파악하고 선택해야 한다.
**레코드 단위**(모든 칼럼, 혹은 대부분의 칼럼)로 접근하고 일반 쿼리, 범위 스캔 요청이 많다면 **로우형 DBMS**가 적합하다.
반면에 많은 로우를 스캔하고, 일부 칼럼에 대한 **집계 작업**이 많다면 **칼럼형 DBMS**가 적합하다.

### 와이드 칼럼 스토어
빅테이블이나 HBase와 같은 **와이드 칼럼 스토어**는 일반적인 칼럼형 DBMS와 다르다.
와이드 칼럼 스토어는 데이터를 **다차원 맵**으로 표현하고, 여러 칼럼을 **칼럼 패밀리 단위**로 저장한다.
> 칼럼 패밀리 : 같은 자료형의 집합

칼럼 패밀리의 데이터는 **로우 형식**으로 저장한다.

이 방식은 **키 단위 액세스 패턴**에 적합하다.

가장 대표적인 구현은 빅테이블 논문에서 설명한 **웹테이블(Webtable)** 이다.
- 웹페이지의 내용과 속성의 **스냅숏**을 시간별로 저장
- **역순 URL**을 페이지의 **식별자**로 사용
- 시간별로 각 속성의 **스냅숏**을 생성
![](files/Pasted%20image%2020230803123436.png)
웹 테이블은 다차원 맵에 데이터를 정렬해서 저장한다.
또한 계층 인덱스를 생성한다.

역순 URL과 시간별 내용, 혹은 앵커 스냅숏을 기반으로 특정 페이지의 정보를 검색할 수도 있다.

각 로우는 로우키(여기서는 역순 URL?)와 매핑하고, 관련있는 칼럼끼리 칼럼 패밀리 단위로 저장한다. 위에서의 칼럼 패밀리는 `contents`, `anchor` 필드

칼럼 패밀리의 칼럼은 **칼럼 패밀리**의 이름(contents, anchor)과 수식자(html, cnnsi.com, mylook.ca)로 구성된 **칼럼 키**로 식별할 수 있다.

칼럼 패밀리는 시간별로 여러 버전의 데이터를 유지한다.

이 자료구조를 사용해 상위 레벨 요소와 관련된 변수를 검색할 수 있다.
즉, 여기서는 웹 페이지와 관련된 시간별 속성을 검색할 수 있다.

와이드 칼럼 스토어의 실제 저장 방식은 복잡하다.
![](files/Pasted%20image%2020230803124033.png)
위 방식이 직관적이지 않아서 HBase의 예를 가져왔는데 타임스탬프를 제외하면 비슷하다.
![](files/Pasted%20image%2020230803123627.png)

### 데이터 파일과 인덱스 파일
DBMS는 데이터를 빠르게 저장하고, 검색할 수 있어야 한다.
이를 위해 **일반적인 파일 구조**를 사용하지 않고 **구현 방식에 맞는 특수 포맷**을 사용한다.
일반 파일을 사용하지 않는 이유는 다음과 같다.
- 저장 효율성
	- 데이터 레코드의 **저장 오버헤드**를 **최소화**하기 위해서
- 접근 효율성
	- **최소한**의 단계로 레코드를 찾기 위해서
- 갱신 효율성
	- 레코드를 갱신할 때 **디스크 쓰기**를 **최소화**하기 위해서

DBMS는 여러 필드로 구성된 레코드를 테이블 형식으로 저장한다.
일반적으로 각 테이블은 별도의 파일에 저장된다.
또한 테이블의 각 레코드는 검색 키로 찾을 수 있다.

레코드의 위치를 찾아낼 때는 **인덱스**를 사용한다.
인덱스는 테이블 전체를 읽지 않고 데이터를 효율적으로 검색할 수 있는 자료 구조이다.
일반적으로 레코드를 식별할 수 있는 필드들의 부분집합으로 인덱스를 구축한다.

DBMS는 **데이터 파일**과 **인덱스 파일**을 분리한다.
데이터 파일에는 **데이터 레코드**를 저장한다.
인덱스 파일에는 데이터 파일에서 레코드의 위치를 찾을 수 있도록 해주는 **메타데이터**를 저장한다.
따라서 인덱스 파일은 일반적으로 데이터 파일보다 크기가 작다.

새로운 레코드나 업데이트된 레코드는 **키-값 쌍의 형식**으로 저장한다.
대부분의 최신 DBMS는 데이터를 즉시 페이지에서 삭제하지 않고 **마킹**한다. -> **삭제 마커, 툼스톤**

수정되거나 마킹된 레코드는 **가비지 컬렉션** 중 최신 레코드로 갱신되며 기존 값은 삭제된다.

### 데이터 파일
데이터 파일은 다음으로 나눠볼 수 있다
- 인덱스 구조형 테이블(IOT, Index-Organized Table)
- 힙 구조형 테이블(Heap-Organized Table)
- 해시 구조형 테이블(Hash-Origanized Table)

힙 파일은 대체로 삽입 순서대로 저장한다.
덕분에 새로운 페이지가 추가되어도 파일을 재구성하지 않아도 된다.
하지만 데이터 검색 시 데이터의 실제 위치를 가리키는 인덱스가 필요하다.

해시 파일은 레코드를 각 키의 해시 값에 해당하는 버킷에 저장한다.
버킷 내 레코드는 삽입 순서대로 저장하는 것도 가능하고 키 순서로 정렬하는 것도 가능하다.

인덱스 구조형 테이블은 인덱스에 실제 데이터 레코드를 저장한다.
데이터는 키 순서로 정렬되므로 IOT의 범위 스캔은 실제 값을 순서대로 읽으면서 비교한다.
> 덕분에 스캔 범위를 최적화할 수 있다

인덱스에 데이터를 직접 저장하면 **디스크 탐색 횟수**를 최소 1회 줄일 수 있다. 인덱스에서 값을 찾고 바로 반환하면 된다.

그러나 실제 데이터 레코드가 다른 파일에 저장되어 있으면 인덱스 파일에 **레코드 식별자**와 **레코드의 위치** 모두 저장해야 한다.
데이터 파일에서 데이터의 위치를 나타내는 오프셋을 저장하거나, 해시 파일에서의 버킷 ID를 저장해야 한다.

### 인덱스 파일
인덱스 파일은 데이터 파일에서 데이터를 찾기 위해서 **키**를 가지고 있다.
힙 파일은 **데이터 레코드를 식별할 수 있는 키**를, IOT 파일은 **기본 키**를 **데이터 파일**의 **레코드 위치에** 매핑한다.

데이터 파일에 대한 인덱스를 **기본(Primary) 인덱스**라고 한다.
**기본 인덱스**는 **기본 키(primary key)** 나 기본 키 역할을 할 수 있는 여러 키 조합에 대한 인덱스다.
기본 인덱스 외에 다른 인덱스는 모두 **보조 인덱스**라고 한다.

보조 인덱스가 레코드를 가리키는 방법은 2가지가 있다.
- 데이터 레코드를 직접 가리키는 방법
	- 데이터 레코드 포인터는 힙 파일이나 IOT 파일의 오프셋이다.
- 해당 레코드의 기본 키를 저장하는 방법
각 방법에 대한 장단점은 '기본 인덱스를 통한 간접 참조' 참조

여러 보조 인덱스가 같은 레코드를 가리키는 것이 가능하다.
> 하나의 레코드는 여러 필드로 식별될 수 있으므로 그에 따라 다양한 인덱스를 만드는 것이 가능하다

**기본 인덱스 파일**은 키별로 하나의 레코드만 가리키지만, **보조 인덱스**는 키별로 여러 레코드를 가리킬 수도 있다.

인덱스 키 정렬 기준에 따라서도 인덱스를 2가지로 구분할 수 있다.
- 클러스터형(clustered) 인덱스
	- 실제 데이터 레코드의 정렬 순서와 검색 키의 정렬 순서가 같은 인덱스
	- 클러스터형 인덱스의 데이터는 보통 같은 인덱스 파일이나, 클러스터형 파일에 정렬해서 저장한다.
- 비클러스터형(unclustered, non-clustered) 인덱스
	- 데이터가 다른 파일이 저장되어 있고, 인덱스 키를 기준으로 정렬되지 않은 인덱스

> IOT는 인덱스 정렬 순서대로 데이터가 저장되므로 클러스터형 인덱스다.
> 기본 인덱스는 대부분 클러스터형 인덱스이다.
> 클러스터형 인덱스는 IOT 형식이거나, 별도의 인덱스 파일과 데이터 파일로 구성될 수 있다.
> 보조 인덱스는 기본 키가 아닌 키로 검색할 때 사용하므로 비클러스터형 인덱스다.

대부분의 데이터베이스 시스템은 데이터 레코드를 식별할 수 있는 칼럼의 집합을 내부 키로 사용한다.
기본 키가 없다면 내부적으로 만들어서 사용한다.

### 기본 인덱스를 통한 간접 참조
인덱스가 데이터를 가지지 않는 경우 데이터를 참조하는 방법이 2가지가 있다.
- 데이터 레코드를 직접 참조
- 기본 키 인덱스를 통해 접근

두 방식 모두 장단점이 있고, 실제 구현에 따라서 조금씩 달라질 수 있다.

데이터를 직접 참조하면 디스크 탐색 오버헤드가 줄어든다.
그러나 갱신하거나 위치를 변경할 때 포인터를 수정해야 하는 오버헤드가 있다.

기본 인덱스를 통해 간접 참조하면 포인터 갱신 오버헤드가 줄어들지만 레코드의 위치를 찾기 위한 추가 탐색이 필요하다.

갱신이 적고 읽기 작업이 많으면 인덱스가 많아도 큰 문제가 되지 않지만 쓰기 작업이 많다면 인덱스 개수가 많다면 포인터 갱신 오버헤드가 문제가 될 수 있다.

따라서 일부 시스템에서는 오프셋 대신 기본키를 이용해 이 오버헤드를 줄인다.
Ex) MySQL InnoDB
보조 인덱스를 이용해 키를 찾고, 기본 인덱스를 통해 해당 레코드를 참조한다. 따라서 기본 인덱스 탐색 비용이 추가로 발생한다.

![](files/Pasted%20image%2020230803172502.png)
경우에 따라서 두 가지를 혼용하는 방식도 있다.
인덱스에 데이터 파일 오프셋과 기본 키를 모두 저장하고, 만약 오프셋이 유효하지 않다면 기본키를 이용해 데이터를 찾고 새로운 오프셋을 저장한다.

### 버퍼링과 불편성, 순서화
스토리지 엔진은 다양한 자료구조를 사용하고, 이에 따라 다양한 특성이 나타나지만 **자료구조**만으로 모든 특성을 설명할 수는 없다.
대표적으로 캐싱, 복구, 트랜잭션 처리 등도 스토리지 엔진이 담당하는데 이를 자료구조만으로 설명할 수는 없다.

데이터베이스 자료 구조에는 3가지 공통점이 있다.
- 버퍼링 사용 유무
- 불편 파일 vs 가변 파일
- 저장할 때 값의 순서 유지 O / X

이 책에서 설명하는 자료구조 차이점이나 최적화 기법을 위 3가지 속성을 통해서도 설명할 수 있다.

- 버퍼링
	- 버퍼링은 데이터를 디스크에 쓰기 전에 메모리에 일부를 저장하는 것이다.
	- 모든 **디스크 기반 자료구조**에서는 버퍼를 어느 정도 사용한다. **블록 단위**이므로 채워서 쓰는게 효율적이다.
	- 그러나 이에 더해서 일부 스토리지 엔진은 **의도적**으로 **버퍼링**을 더 사용하기도 한다. 이러한 버퍼링을 자료구조나 최적화 관점에서 다룬다.
- 가변성(불변성)
	- 파일 일부를 읽고 갱신할 때 같은 자리의 값을 고치거나, 끝에 추가하거나 등의 속성이다.
	- 불변 구조는 한 번 쓴 파일 내용은 고칠 수 없다. 파일 끝에만 내용을 추가하는 **추가 전용(append-only)** 구조이다.
	- 불변성은 다양한 방법으로 구현할 수 있다.
		- 예를 들어 **쓰기 시 복사(copy-on-write)** 방식이 있는데, 이 방식은 **갱신**된 버전의 레코드를 갖고있는 **수정된 페이지**를 기존 위치가 아니라 해당 파일 내 **새로운 위치**에 저장한다.
			- 즉, 수정된 페이지를 새로운 위치에 저장한다.
	- 각 자료구조마다 이러한 특성이 달라진다.
- 순서화
	- 디스크 페이지에 데이터 레코드를 키 순서로 저장하는 특성이다.
	- 정렬 순서에 따라서 디스크의 연속된 세그먼트에 저장되는 값들이 달라지므로 중요하다.
		- 특정 레코드를 검색하거나, 범위 스캔할 때 효율성을 높일 수 있다.
	- 그러나 데이터를 임의의 순서대로 저장하면 쓰기 시간을 최적화할 수 있다
		- 일반적으로 삽입 순서

## 2장 B-트리 개요

자료 구조를 **가변 구조**와 **불변 구조**로 나눴었다.
가변 자료 구조는 **인플레이스 업데이트** 방식을 사용한다.
데이터 삽입, 삭제, 업데이트시 데이터 저장 위치에 새로운 데이터를 **즉시** 쓴다.

스토리지 엔진은 보통 여러 버전의 레코드를 데이터베이스에 저장한다. 예를 들면 다음과 같은 방식이 있다.
- 다중 버전 동시성 제어(multi-version concurrency control)
- 슬롯 페이지 구조(slotted page organization)

다만 이 책에서는 쉽게 이해할 수 있게 모든 키는 한 개의 레코드만 가리킨다고 생각한다.

![](files/Pasted%20image%2020230803185912.png)
슬롯 페이지 구조는 위와 같은 구조를 가지면서 채워나가는 방식이다.

B-트리는 가장 많이 사용되는 자료 구조이며, 대다수의 오픈소스 데이터베이스에서 사용된다.
또한 수년 동안 다양한 사용 사례를 통해 검증되었다.

B-트리는 1971년에 처음 나와 이미 다양한 형태의 새로운 B-트리가 1970년대에 나왔었다.

### 이진 탐색 트리
이진 탐색 트리(BST, Binary Search Tree)는 **정렬**된 **인메모리 자료 구조**이다.
**키-값 쌍 검색**에 주로 사용된다.

키와 두 개의 자식 포인터가 저장된 여러 노드로 구성된다.
탐색은 루트 노드에서 시작한다.
트리에는 단 한개의 루트 노드만 존재할 수 있다.

![](files/Pasted%20image%2020230803190328.png)
각 노드의 키는 왼쪽 서브트리의 모든 노드 키보다 크고, 오른쪽 서브트리의 모든 키보다 작다.
따라서 탐색 과정에서 탐색 공간을 매번 줄여나갈 수 있다.

왼쪽 포인터를 쭉 타고 내려가면 최솟값을, 오른쪽 포인터를 쭉 타고 내려가면 최댓값을 찾을 수 있다.
탐색 과정에서 중간에 원하는 값을 찾을 수도 있으므로 리프 노드에 도달하기 전에 탐색이 끝날 수도 있다.

### 트리 밸런싱
노드 삽입 패턴에 따라서 트리가 불균형해질 수도 있다.
![](files/Pasted%20image%2020230803190511.png)
균형 트리란 노드 개수가 N일 때 높이가 logN이고 두 서브 트리의 높이 차이가 1인 트리다.

균형 트리는 매번 탐색할 때마다 탐색 공간이 약 2배씩 줄어드므로 탐색 시간 복잡도가 O(logN)이지만 불균형 트리의 최악의 시간 복잡도는 O(N)이다.

따라서 우리는 노드를 추가하는 과정에서 트리가 치우치지 않도록 매 삽입마다 균형을 유지할 필요가 있다.
트리를 재구성해 높이를 최소화하고, 서브트리의 노드 수를 일정 수로 제한해 균형을 유지할 수 있다.
> 서브트리의 노드 수를 제한한다는 것은 이진 트리가 아니라 자식의 개수가 많아질 수 있을 때?

트리의 균형을 유지하는 방법 중 하나는 노드를 추가하거나 삭제할 때 트리를 회전하는 것이다.
노드 삽입으로 인해 트리의 균형이 깨진다면(연속된 두 개의 노드의 자식이 한 개인 경우) 가운데 노드를 중심으로 회전한다.
![](files/Pasted%20image%2020230803190821.png)
이러한 성질은 **AVL 트리**는 물론 여러 자료 구조가 갖는 성질이다.
### 디스크 기반 스토리지용 트리
**이진 탐색 트리**는 트리의 **팬아웃**이 낮기 때문에 **트리 밸런싱**, **노드 재배치**, **포인터 갱신**이 자주 발생한다.
따라서 이진 탐색 트리는 **높은 트리 유지 비용** 때문에 **디스크 기반 자료 구조**로는 적합하지 않다.
> 팬아웃(fanout) : 노드가 가질 수 있는 최대 자식 노드 개수

BST를 디스크에서 제어하면 다음과 같은 문제를 만난다.
- 지역성
	- 노드가 키 순서로 삽입되지 않아 **부모 노드**와 **자식 노드** 사이의 거리가 멀 수 있다
	- 따라서 자식 포인터가 여러 다른 디스크 페이지를 가리킬 수도 있다.
		- 매 노드 접근마다 디스크 탐색이 필요할 수도 있다.
	- 이런 문제는 **페이지 이진 트리**를 사용하면 **일부 해결**할 수는 있다.
		- 노드들을 같은 페이지로 그룹화
- 트리의 높이
	- 이진 트리는 **팬아웃**이 2라 높이는 logN이다.
	- 따라서 특정 노드를 찾기 위해서 최대 **O(logN)** 번의 **탐색**과 **디스크 전송**이 필요하다.
	- 메모리에서는 이런 점이 크게 문제되지 않으므로 BST는 **인메모리 자료 구조**로는 유용하지만, **디스크 자료 구조**에서는 노드의 크기가 작아 **비효율**적이다.

디스크 기반 BST 구현은 **지역성**을 고려하지 않으므로 최악의 경우 **비교 횟수**만큼 **디스크 탐색**이 필요하다.
따라서 디스크 기반 트리를 선택할 때 지역성이 떨어지는 자료 구조는 피해야 한다.

즉, 디스크 저장에 적합한 트리는 두 가지 특성을 가져야 한다.
- 인접한 키의 **지역성**을 높이기 위한 **높은 팬아웃**
- 트리 순회 중 **디스크 탐색 횟수**를 줄이기 위한 **낮은 트리 높이**

### 디스크 기반 자료 구조
**디스크**에 적합한 자료 구조가 있고, **메모리**에 적합한 자료구조가 있다.
공간, 시간 복잡도 모두 만족하는 자료 구조라도 디스크에 적합하지 않을 수 있다.
데이터베이스 자료 구조는 반드시 **디스크**와 같은 **영속적 저장 매체의 한계**를 고려해야 한다.

디스크 기반 자료 구조는 데이터를 메모리에 전부 저장할 수 없을 때 주로 사용하므로, 일부는 메모리에 **캐시**해서 사용하고, 나머지는 효율적으로 접근할 수 있는 형태가 되도록 디스크에 저장해야 한다.

## 하드 디스크 드라이브
전통적인 알고리즘은 디스크 드라이브를 사용할 때 만들어진 것들이 많아 여기에 최적화된 것들이 많다.
다만 플래시 드라이브와 같이 새로운 저장 매체가 나타나면서 이에 최대한 활용하도록 기존 알고리즘을 수정하거나, 새로운 알고리즘을 만들어내기도 한다.

디스크에서는 **탐색 작업**이 **랜덤 읽기 비용**의 많은 부분을 차지한다.
디스크를 회전하고, 헤드를 **물리적**으로 원하는 위치까지 옮겨야 하기 때문이다.
다만 이후의 연속된 바이트 읽기/쓰기 작업은 상대적으로 비용이 낮다.
![](files/Pasted%20image%2020230803194000.png)

디스크의 최소 전송 단위는 **섹터(sector)** 다. 모든 작업은 최소 한 개의 섹터를 읽거나 쓴다.
섹터의 크기는 보통 512 바이트 ~ 4kb 사이다.

물리적 헤드 이동은 HDD 작업 중 가장 비용이 높으므로 최대한 연속된 메모리 섹터를 읽거나 쓰는 **순차적 I/O**를 극대화해야 한다.

### 솔리드 스테이트 드라이브
디스크와 달리 물리적으로 움직이는 부품이 없다.
SSD는 **메모리 셀**로 구성되며, **셀**을 연결하면 **스트링**이 되고, **스트링의 배열**이 **페이지**가 되고, **페이지**가 모여서 **블록**이 된다.

구현 방식에 따라서 셀은 한 개 또는 여러 개의 비트를 저장한다.
> SLC, MLC, TLC, QLC

페이지의 크기도 기기마다 다르지만 보통 2~16KB 정도다.
블록은 일반적으로 64 ~ 512 개의 페이지로 구성된다.
**블록의 집합**은 **플레인**, **플레인의 집합**은 **다이**라고 부른다.
SSD는 한 개 이상의 다이로 구성된다.

![](files/Pasted%20image%2020230803200900.png)
**페이지**는 읽고 쓸 수 있는 가장 작은 단위다.
쓰기 동작은 비어 있는 메모리 셀(값이 삭제된)에만 쓸 수 있다.

하지만 삭제할 수 있는 최소 단위는 페이지가 아니라 **블록**이다.
> 삭제 블록(erase block)이라고도 부른다.

블록 내 페이지는 순차적으로 쓴다.

SSD에는 메모리를 관리하는 메모리 컨트롤러가 있고, 이를 플래시 변환 레이어(FTL, Flash Translation Layer)라고 부른다.
FTL은 페이지 ID를 실제 위치와 매핑하고, 비어있는, 쓰여진, 삭제된 페이지를 관리한다.

블록을 안전하게 삭제하기 위해서는 블록을 비워야 한다. FTL은 안전하게 지울 수 있는 블록을 찾는 동안 **가비지 컬렉션**도 수행하는데, 이미 사용 중인 페이지를 다른 곳으로 옮겨 블록을 삭제할 수 있게 만든다.

HDD와 SSD는 개별 바이트 단위(데이터 블록 단위)가 아니라 메모리 청크 단위로 데이터를 참조한다.
따라서 대부분의 운영체제에는 **블록 디바이스 추상화 계층**이 있다.
이 계층은 HDD의 내부 구조를 추상화하고, I/O 작업을 내부적으로 버퍼링한다.

블록 디바이스는 하나의 워드를 읽더라도 워드의 **블록 전체**를 읽게 된다. 이는 **디스크 기반 자료구조**에서 염두해야 하는 중요한 제약사항 중 하나다.

SSD는 HDD와 달리 순차 I/O, 랜덤 I/O 구분이 중요하지 않다. 둘 간의 **레이턴시** 차이가 거의 없다.
그러나 프리페치와 연속된 페이지 읽기, 내부 병렬 처리 등으로 인해 차이는 여전히 존재한다.
![](files/Pasted%20image%2020230803194000.png)

**가비지 컬렉션**은 백그라운드 작업임에도 불구하고 **쓰기 성능**을 저하시킬 수 있다.
**랜덤 쓰기**와 **비정렬(unaligned) 쓰기** 작업이 특히 그렇다.

**전체 블록 단위**로 쓰거나, **같은 블록에 대한 쓰기 작업**을 모아서 한번에 처리하면 **I/O 작업**을 줄일 수 있다.
**버퍼링**, **불변성**을 활용해서 이러한 문제를 줄일 수 있다.

### 디스크 기반 자료 구조
디스크 기반 자료 구조 설계가 어려운 이유는 **디스크의 접근 비용**도 물론 있지만, 가장 어려운 점은 가장 작은 작업 단위가 **블록**이라는 것이다.
블록의 특정 위치만 가져오려고 해도 블록 전체를 읽는다.

대부분의 디스크 기반 자료 구조는 포인터를 직접 관리한다. 포인터 연산처럼 주소를 계산하고, 포인터가 가리키는 주소를 명시적으로 따라가야 한다.

포인터가 가리키는 부분이 저장되는 것보다 디스크에 포인터를 미리 저장하는 경우 **사전에 디스크 오프셋을 계산**하기도 한다.
혹은 메모리에 캐시된 다음 디스크로 플러시된다.
> ..?

디스크 기반 자료 구조에 긴 종속 관계가 만들어지면 유지 관리도 어렵고, 구조가 매우 복잡해지므로 전체 포인터 수를 제한하고, 저장 범위를 최소화하는 것이 좋다.

즉, 정리하면 다음과 같다.
- 저장 매체의 구조를 고려해서 설계해 **디스크 접근 횟수**를 최소화
- 내부 구조를 최적화하고, **지역성**을 높여서 **페이지를 넘나드는 포인터** 최소화

디스크 기반 자료 구조는 **팬아웃**이 높고, **높이**가 낮아야 이상적이다.
하지만 포인터를 쓰면 **저장하는 오버헤드**, 트리의 균형을 맞춘 뒤 **포인터를 다시 매핑하는 오버헤드**가 생긴다.
**B-트리**는 이런 문제를 해결하기 위해 **팬아웃**을 크게하고, **높이**와 **노드 포인터의 개수**, **밸런싱 빈도**를 줄인 트리다.

![](files/Pasted%20image%2020230803202523.png)
- 이진 트리의 노드를 페이지로 묶으면 같은 페이지 내에서 자식 노드를 찾을 수 있다.
- 하지만 키와 값이 정렬되어 있지 않고, 레코드가 무작위로 추가된다면 트리의 균형을 맞추기 위해서 페이지를 재구성하고, 포인터를 업데이트 하는 과정에서 오버헤드가 생길 수 있다.
- 즉, 관리가 쉽지 않다.

### 유비쿼터스 B-트리
B-트리는 검색 항목을 빠르게 찾을 수 있는 **계층형 자료 구조**다.
B-트리는 **팬아웃**이 높고, **높이**가 낮은 **이진 탐색 트리** 기반의 **트리**이다.

![](files/Pasted%20image%2020230803202917.png)
결국 이진 트리나 B-트리나 키에 따라 트리가 서브 트리로 분할되고, 키를 사용해 트리를 탐색하고 키를 찾는다.

B-트리는 **키의 순서**가 보장된다.
**노드 키**를 기준으로 **정렬**해서 저장하기 때문에 **이진 탐색**과 같은 알고리즘을 사용해서 특정 키를 찾을 수 있다.
따라서 B-트리의 탐색 시간 복잡도는 **로그 시간**이다.

모든 비교 연산 마다 디스크에 접근해야 한다면 매우 탐색이 느릴 것이다.
B-트리의 노드에는 수십, 수백 개의 키를 저장하고, 한 번의 디스크 탐색으로 가져올 수 있으므로 B-트리는 **레벨별로 디스크를 한 번만 탐색**하면 된다.

B-트리를 사용하면 **포인트 쿼리**나 **범위 쿼리**를 효율적으로 처리할 수 있다.
- 포인트 쿼리 : = 사용해서 개별 원소 검색
- 범위 쿼리 : <, >, <=, >= 등의 조건식 사용해서 여러 원소 검색

### B-트리 계층
B-트리는 여러 개의 노드로 구성된다.
각 노드는 최대 N개의 키, N+1개의 자식 포인터를 가진다.
- 루트 노드
	- 트리의 최상위 노드
	- 부모 노드가 없다
- 내부 노드
	- 루트와 리프 노드를 연결하는 모든 노드
	- 트리에는 일반적으로 한 레벨 이상의 내부 노드가 있다
- 리프 노드 
	- 자식 노드가 없는 트리의 최하위 계층 노드
![](files/Pasted%20image%2020230803204747.png)
B-트리는 **페이지** 기반 자료 구조다.
**고정 크기**의 페이지 단위로 구성되어 있다.
따라서 노드와 페이지를 같은 의미로 사용하기도 한다.

보유 가능한 **노드 용량(capacity)** 과 실제로 보유하고 있는 **키의 개수**의 비율을 **점유율(occupancy)** 라고 한다.

B-트리에서 팬아웃은 각 노드에 저장할 수 있는 키의 최대 개수를 말한다.
팬아웃이 높으면 트리의 균형 유지에 필요한 **트리 구조 변경 비용**을 낮출 수 있다. 또한 키와 포인터를 **같은 블록**, 혹은 **연속된 블록**에 저장해 불필요한 탐색을 줄일 수 있다.

**밸런싱 작업**은 **분할**과 **병합**으로 구성되는데, 빈 공간이 없거나, 거의 비었을 대 수행한다.

지금까지 설명한 트리의 정확한 이름은 B+-트리다.
B-트리는 루트와 내부, 리프 노드에 모두 값을 저장할 수 있다.
하지만 B+-트리는 **리프 노드**에만 값을 저장할 수 있다. **내부 노드**에는 **리프 노드**의 값을 찾기 위해 검색 알고리즘에 필요한 **구분(seperator) 키**만 저장한다.

B+-트리는 리프 노드에 값을 저장하므로 모든 수정 및 검색 작업은 리프 노드에만 영향을 미친다. 상위 노드는 분할, 병합이 일어날 때만 영향을 받는다.

B+-트리가 여러 분야에서 사용되어 여러 곳에서 B+-트리를 B-트리라고 부르기도 한다.

> 팬아웃이 높은 트리를 멀티웨이(multiway) 트리라고 부르기도 한다.

### 구분 키
B-트리 노드에 저장된 키를 다음 이름으로 부른다.
- 인덱스 엔트리
- 구분 키
- 디바이더 셀(divider cell)
각 키는 트리를 해당 키 범위의 **서브트리**로 **분할**해 트리를 타고 내려가면서 이진 검색할 수 있다.
> 서브트리를 브랜치 혹은 서브레인지(subrange)라고도 부른다

노드의 첫 번째 포인터는 해당 키보다 **작은** 키가 저장된 **서브트리**를 가리킨다.
마지막 키는 해당 키보다 같거나 **큰** 키가 저장된 **서브트리**를 가리킨다.

![](files/Pasted%20image%2020230803205824.png)
**일부 변형 B-트리**는 효율적인 **범위 스캔**을 위해 **리프 노드**에 **형제 노드**를 가리키는 포인터를 저장하기도 한다. 이렇게 하면 부모 노드를 거치지 않고 바로 형제 노드에 접근할 수 있다.
리프 노드를 연결하는 **이중 연결 리스트**를 만들어서 양방향 탐색할 수 있게 만드는 구현도 있다.

이진 트리는 하향식으로 만들어지지만, B-트리는 상향식으로 트리를 구성한다.
**리프 노드**가 많아질수록 **내부 노드**와 **높이**가 증가한다.

B-트리는 나중에 삽입, 업데이트될 노드의 공간을 **미리 확보**한다. **공간 활용률**은 50%까지 낮아질 수 있지만 일반적으로는 이보다 꽤 높다.
**점유율**이 높다고 B-트리 **성능**에 부정적인 영향을 주지는 않는다.

### B-트리 탐색의 시간 복잡도
B-트리 탐색의 시간 복잡도는 **블록 전송 횟수**와 **비교 횟수** 관점에서 계산할 수 있다.

전송 횟수 관점에서 복잡도의 로그 밑은 `N`이다.(각 노드별 키 개수)
각 레벨에는 이전 레벨보다 `K`배 많은 노드가 있고, 탐색 공간이 `N`의 비율로 감소한다.
특정 키를 찾기 위해서는 최대 `logk M`개의 **페이지**에 접근해야 한다. (M : 전체 노드  개수)
루트에서 리프까지 거쳐가는 자식 포인터의 수는 트리의 **최대 레벨**, **높이**와 같다.

비교 횟수 관점에서 보면 **이진 탐색**을 사용해 키를 찾으므로 복잡도의 로그 밑은 2이며, 매 탐색마다 탐색 공간이 절반으로 줄어드므로 `log2 M`이다.

일반적으로 B-트리의 탐색 시간 복잡도는 `log M`이라고 하는데, 로그의 밑이 복잡도 계산에 영향을 주지 않기 때문이다.

### B-트리 탐색 알고리즘
B-트리에서 특정 값을 찾으려면 **루트**에서 **리프 레벨**까지 **순회**해야 한다.
B-트리에서의 탐색의 목적은 **특정 키** 또는 **바로 앞 키**를 찾는 것이다.
**포인트 쿼리**, **업데이트**, **삭제** 작업은 **정확히 일치하는 키**를 찾아야 한다.
**범위스캔**, **새로운 노드 삽입** 시 대상 키의 **바로 앞 키**를 찾아야 한다.

탐색 알고리즘은 **루트 노드**부터 **이진 탐색**을 수행한다.
검색 키보다 **큰 첫 번째 구분 키**를 찾아 **서브트리**를 찾고 리프 노드까지 포인터를 따라간다.
낮은 레벨로 내려갈수록 검색 범위가 점점 줄어든다.
**구분 키**는 인접한 두 개의 키 사이의 **범위**를 포함하는 **서브트리**를 가리킨다.
탐색 과정을 반복하면서 대상 키를 찾아 반환하거나, 존재하지 않으면 바로 앞의 값을 반환한다.

**포인트 쿼리**는 특정 키를 찾거나, 찾지 못했을 때 완료된다.
**범위 스캔**은 범위의 끝에 도달하거나, 더 이상 조건을 충족하지 않는 노드를 찾을 때 종료된다.

### 키 개수
**키**와 **자식 오프셋 수**를 계산하는 다양한 방법이 있다.

한 논문은 장치의 **최적의 페이지 크기**를 나타내는 자연수 k를 기반으로 계산한다.
페이지에 k ~ 2k 개의 키가 있으며, 최소 k + 1 ~ 2k + 1개의 자식 노드를 가리키는 포인터를 저장할 수 있다.
루트 페이지는 1 ~ 2k 개의 키를 포함할 수 있고, 리프가 아닌 모든 페이지는 최대 I + 1 개의 키를 포함한다.

다른 논문은 각 노드에 최대 N개의 구분키와 N + 1포인터를 저장할 수 있다고 설명한다.

두 방식 모두 계산 결과는 같다. 설명 방식만 다르다.
이 책에서는 `N`을 키의 개수(리프 노드는 키-값 쌍의 개수)로 정의한다.

### B-트리 노드 분할
새로운 노드를 삽입하려면 대상 리프를 찾고 삽입 위치를 결정해야 한다.
탐색 알고리즘을 통해 리프 노드를 찾고, 새로운 키-값 쌍을 추가한다.
업데이트도 마찬가지로 대상 리프 노드를 찾고 기존 키 값을 업데이트한다.

리포 노드에 남은 공간이 없는 노드를 **오버플로우 상태**라고 표현한다. 오버플로우 상태의 노드에 새로운 키를 삽입하려면 노드를 **분할**해야 한다.
노드 분할 작업의 조건은 다음과 같다.
- 리프 노드 : 노드에 최대 N개의 키-값 쌍을 저장할 수 있고, 새로운 키 삽입 시 용량이 초과되는 경우
- 리프가 아닌 노드 : 노드에 최대 N + 1 개의 포인터를 저장할 수 있고, 포인터 추가시 용량이 초가되는 경우

노드 분할은 **새로운 노드**를 할당해 **키의 절반**을 **새로운 노드**로 옮기고, **첫 번째 키**와 **포인터**를 **부모 노드**에 **추가**하는 방식으로 이뤄진다. 이 키를 **승급(promote)** 했다고 표현한다.
분할 이 발생한 키를 **분할 지점(미드포인트)** 라고 부른다. 이 키의 앞 키는 그대로 남겨지고, 나머지 키는 새로운 형제 노드로 옮겨진다. 리프 노드의 분할인 경우 분할 지점도 새로운 형제 노드로 옮겨진다.
부모 노드에 승급 키와 포인터를 추가할 공간이 없는 경우 부모 노드도 분할해야 하며, **루트 노드**까지 재귀적으로 분할될 수도 있다.

트리에 **용량**이 부족해 루트 노드까지 분할이 전파되면 **루트 노드**를 분할해야 한다.
분할 지점의 키를 포함하는 **새로운 루트 노드**를 만들고, 기존의 **루트 노드**(기존 키의 절반)와 생성된 **형제 노드**는 다음 레벨로 강등되면서 트리의 **레벨**이 한 단계 증가한다.

즉, **루트 노드**가 **분할**되거나 **병합**될 때 트리의 **높이**가 변하며, **리프**와 **내부 노드 레벨**에서는 트리가 **수평적으로만 확장**한다.

![](files/Pasted%20image%2020230803213214.png)
![](files/Pasted%20image%2020230803213630.png)
리프가 아닌 노드의 분할은 항상 하위 레벨의 노드 분할로 인해 발생하므로, 새로운 포인터(새로운 형제 노드를 가리키는 포인터)가 추가된다.
> 리프 노드 분할은 포인터가 추가가 안되나..?

분할할 때 리프 노드 여부는 중요하지 않다. 리프 노드를 분할할 경우 키와 값 모두를 옮긴다.

분할이 끝나면 두 노드 중에서 **새로운 키를 삽입할 노드**를 선택한다.
구분 키의 속성에 따라서 **삽입할 키**가 **승급된 키**보다 작다면, **분할 노드**에 삽입하고 더 크다면 **새로운 노드**에 삽입한다.

노드 분할을 요약하면 다음과 같다.
1. 새로운 노드 할당
2. 분할 노드 키의 절반을 새로운 노드로 복사
3. 새로운 키를 알맞은 노드에 삽입
4. 분할 노드의 부모 노드에 분할 키와 새로운 노드를 가리키는 포인터 추가

### B-트리 노드 병합
키를 삭제할 때는 대상 키가 포함된 **리프 노드**를 찾고, 키와 값을 삭제한다.

키를 삭제하다 보면 노드에 저장된 값이 너무 적은 경우가 생기는데 이를 **언더플로우(underflow)** 라고 하며 **형제 노드**를 **병합**해야 한다.

만약 형제 노드의 부모가 같고, 한 개의 노드로 합칠 수 있다면 두 노드를 병합한다.
그러나 한 개의 노드로 합칠 수 없다면 키를 두 노드 사이에 재분배하고, 균형을 맞춘다.

노드 병합 조건은 다음과 같다.
- 리프 노드 : 노드에 최대 N개의 키-값 쌍을 저장할 수 있고 두 노드의 총 키-값 쌍의 수가 N보다 작거나 같은 경우
- 리프가 아닌 노드 : 노드에 최대 N + 1 개의 포인터를 저장할 수 있고 두 노드의 포인터 수의 합이 N + 1 보다 작거나 같은 경우

![](files/Pasted%20image%2020230803214439.png)
키 16의 삭제로 인한 리프 노드의 병합 과정이다.
일반적으로 오른쪽 노드에서 왼쪽 노드로 옮기지만 **키 순서**만 보장되면 반대도 상관없다.

![](files/Pasted%20image%2020230803214556.png)
**비 리프 노드**를 병합하면 **부모 노드**에서 해당 **구분 키**를 가져오게 된다.
또한 하위 레벨의 **페이지**가 **삭제**되면서 부모 노드의 **포인터 수**도 하나 줄어든다. 따라서 분할과 마찬가지로 **병합**도 **부모 노드**로 전파될 수 있다.

키가 삭제될 때 노드 병합은 다음과 같이 이루어진다.
1. 모든 키를 오른쪽 노드에서 왼쪽 노드로 복사
2. 부모 노드에서 오른쪽 노드를 가리키는 포인터 제거 (비리프 노드 병합이라면 강등)
3. 오른쪽 노드를 제거

### 요약
**이진 탐색 트리**는 복잡도 관점에서는 디스크에 적합해보이지만 **팬아웃**이 낮고, **균형**을 맞추기 위해 **재배치**와 **포인터 업데이트**가 자주 발생해 적합하지 않다.
반면 **B-트리**는 노드에 더 많은 키를 저장해 **팬아웃**이 높고, **리밸런싱** 작업 빈도가 더 낮아 디스크에 적합하다.

B-트리는 노드 삽입 또는 삭제 시 노드 분할과 병합을 통해 균형을 유지한다.
트리의 높이를 최소한으로 유지해야 하며, 키 추가 시 사용 가능한 공간이 남아있는 노드를 최대한 활용해야 한다.

디스크 기반 B-트리의 특성은 **인메모리 B-트리 설계**에도 적용 가능하다.
다만 디스크 키반 B-트리를 구현할 때는 **노드 저장 방식**과 **데이터 인코딩 포맷**을 신중하게 결정해야 한다.
