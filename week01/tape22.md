# 1부 스토리지 엔진


데이터베이스는 모듈식 시스템이다.

- 요청을 전달하는 전송계층
- 가장 효율적인 쿼리 실행 계획을 결정하는 쿼리 프로세서
- 실행 엔진
- 스토리지 엔진

    - 데이터를 메모리와 디스크에 저장하고 검색 및 관리하는 소프트웨어 컴포넌트, 노드를 영구히 저장한다.
    - 스토리지 엔진이 제공하는 API 를 통해서 사용자가 레코드를 CRUD 할 수 있다.
    - 키와 값은 모두 임의의 바이트 시퀀스로, 스토리지 엔진 관점에서는 int32나 아스키코드나 모두 직렬화된 값이다.


## 데이터베이스 비교

데이터베이스는 교체해야할 때 마이그레이션이 쉽지 않을 수 있으므로 개발 초기단계에 어떤 데이터베이스 시스템을 선택할지 고려해야한다.


### 목표는 무엇인가?
<br>

> 이미 기존에 파악된 워크로드를 처리하거나, 목표수치를 달성할 수 있는 데이터베이스를 찾는 경우 실제 워크로드를 시뮬레이션하면서 성능 메트릭을 측정하고 비교해야한다.

<br>

- 스키마와 레코드 크기
- 클라이언트 수
- 쿼리 형식과 접근 패턴
- 읽기와 쓰기의 쿼리 비율
- 위 변수들의 변동폭
- 단일 노드는 몇 건의 읽기/쓰기 요청을 처리할 수 있는지
- 시스템에는 몇 개의 노드가 필요한지
- 요청된 쿼리를 수행하고 데이터를 모두 저장할 수 있는지
- 데이터 증가 추세에 맞춰 클러스터를 확장할 수 있는지
- 유지보수는 어떻게 할 것인지

테스트 클러스터를 생성하고 워크로드를 시뮬레이션, 데이터베이스에서 제공하는 부하 테스트 툴을 사용하여 부하 테스트
해당 데이터베이스의 소스코드를 분석하기
최신 버전에는 어떤 것들이 변경되었고 왜 변경되었는지를 파악하는 것이 좋다.



사례: 이벤트 응모권 용 데이터를 어디다 적재할 것인가?

<br>

# 1장

자료구조 데이터 파일과 인덱스 파일의 관계를 파악해야한다.
버퍼링, 불변성, 순서화에서는 효율적으로 스토리지를 설계하는데 사용되는 기법


## 1-1. DBMS 구조

클라이언트 요청은 트랜스포트 서브시스템을 통해 전달

- 요청은 쿼리 형태 -> 쿼리 프로세서가 전달받아 쿼리 해석, 분석 및 검증 -> 쿼리 옵티마이저가 효율적인 쿼리 실행계획 생성

    - 쿼리 수행에 필요한 관계형 연산을 **종속 트리**로 변환하는 일 / 인덱스 순서 선택 / 카디널리티 예측 / access method 선택 등 최적화. 동일 쿼리에도 다양한 여러 쿼리플랜이 있을 수 있다.

- 쿼리플랜이 선택 -> 실행엔진이 로컬 및 원격 실행 결과를 결합 -> 스토리지 엔진은 로컬 쿼리 수행

    - 트랜잭션 매니저 : 트랜잭션 스케줄링, 논리적 일관성을 보장
    - 락 매니저 : 트랜잭션에 접근하는 객체 잠금 제어
    - 액세스 메소드 : 디스크에 저장된 데이터 접근 및 저장방식을 정의 (힙 파일, B-Tree, LSM 트리 등을 사용)
    - 버퍼 매니저 : 데이터 페이지를 메모리에 캐시
    - recovery 매니저 : 로그를 유지관리하고 장애 발생 시 시스템 복구


트랜잭션과 락 매니저는 동시성을 제어 (논리적, 물리적 데이터 무결성을 보장하고 동시수행작업의 효율적인 수행을 담당)

<br>

## 1-2. 인메모리 VS 디스크 기반 DBMS


DBMS는 데이터를 메모리와 디스크에 저장

- 인메모리 : 메모리에 데이터 저장(RAM) / 디스크는 복구, 로그 저장 용도
- 디스크 : 디스크에 데이터 저장 / 메모리는 캐시, 임시 저장용도


인메모리 기반 데이터베이스는 상대적으로 낮은 데이터 접근 비용, 제어의 간편성, 성능 때문에 주로 사용한다. 개발자는 임의의 메모리 청크를 할당하고 해제하는 작업 정도만으로 메모리를 간단하게 제어할 수 있다.

하지만 단점은 RAM의 휘발성과 가격. 영구적이지 않기 때문에 장애 및 정전으로 데이터가 손실될 수 있다.
- 데이터 지속성 및 데이터 손실 방지를 위해 디스크에 데이터를 백업한다.
- 모든 작업을 로그파일에 순차적으로 기록하며, 시스템 시작 및 복구 시 유지하는 백업본을 디스크에 저장한다.
- 비동기적으로 갱신되며, 배치 작업 단위로 백업한다.

로그 레코드는 일반적으로 배치 단위로 백업하며, 특정 시점의 스냅샷이 되기 때문에 이전 시점의 로그는 삭제한다. (checkpoint)

디스크 기반 데이터베이스는 디스크 접근에 특화된 자료 구조를 사용하며, 넓고 낮은 트리 형태이다. 가변 크기의 데이터 제어가 복잡해질 수 있지만 메모리는 포인터를 사용하여 쉽게 제어할 수 있다.

<br>
---

## 1-3. 칼럼형 vs 로우형 DBMS

데이터를 디스크에 저장하는 방식에 따라 데이터베이스를 분류할 수 있다.

- 칼럼 저장 방식 : 같은 칼럼에 속하는 값들을 함께 저장하는 수직분할 방식

    - MonetDB, C-Store, 아파치 Parquet, Kudu 등
    - 칼럼 별로 다른 파일 또는 세그먼트에 저장하면 효율적으로 데이터를 읽을 수 있다. 로우와 다르게 필요한 특정 컬럼만 읽어올 수 있다.
    - 주식시세, 데이터 추세, 평균 등을 계산하는 집계 분석 작업에 적합하다.
    - 하지만 각 칼럼 사이의 관계를 정의하는 메타데이터가 중복되기 때문에 데이터가 증가한다.
    - 같은 칼럼의 여러 값을 한꺼번에 읽으면 캐시 활용도와 처리 효율성은 높아진다. 자료형 별로 저장하면 압축률도 증가한다.

<br>

- 로우 저장 방식 : 같은 로우에 속하는 값들을 함꼐 저장하는 수평분할 방식

    - MySQL, PostgreSQL
    - 데이터 레이아웃은 모든 로우의 구성필드가 같다. 여러 필드 값을 고유 식별 키로 구분할 수 있는 레코드 형식에 적합하다.
    - 한 개의 로우씩 접근하는 경우 유용하며, spatial locality를 극대화할 수 있다. 디스크 같은 반영구적 저장매체에 저장된 데이터는 블록 단위로 접근하기 때문에, 한 블록에 모든 컬럼 값을 저장한다.


액세스 패턴을 파악해서, 일반 쿼리와 범위 스캔 요청이 많으면 로우형. 많은 로우를 스캔하거나 일부 칼럼 집계 작업이 많다면 칼럼형을 선택하는 것이 적합하다.

<br>

**  와이드 칼럼 스토어 : url을 역순으로 저장해서 식별자로 사용하고, 시간 별 속성의 스냅숏을 생성한다.



<br>

---
## 1-4. 데이터 파일과 인덱스 파일

데이터베이스 시스템은 파일에 데이터를 저장하는데,

- 저장 효율성
- 접근 효율성
- 갱신 효율성

을 위해 특수한 포맷을 사용한다.

데이터베이스 시스템은 보통 레코드를 테이블 형태로 저장하며, 각 테이블을 별도의 파일에 저장하고 검색 키로 찾는다.
레코드의 위치는 인덱스를 사용하는데, 테이블 전체를 읽지 않고도 효율적으로 데이터를 검색할 수 있는 자료구조이다.

- 데이터 파일(primary file) : 실제 데이터 레코드 저장

    - 인덱스, 힙, 해시 구조형 테이블을 기반
    - 힙 파일: 레코드를 특정 순서에 따르지 않고 삽입되는 대로 저장. 재구성 불필요하나 데이터 검색 시 인덱스가 필요하다.
    - 해시 파일: 레코드를 각 키의 해시 값에 해당하는 버킷에 저장. 버킷 내 레코드는 삽입 순으로 저장, 키 순서로 정렬
    - 인덱스 파일: 인덱스에 실제 레코드를 저장. key 순서대로 정렬
- 인덱스 파일 : 레코드 메타데이터 저장, 해당 값으로 레코드 위치 파악

    - 기본 인덱스는 기본 키, 기본키 역할의 여러 키 조합에 대한 인덱스이다. 나머지는 모두 보조 인덱스로, 데이터 레코드를 직접 가리키거나 해당 레코드의 기본키를 저장한다.
      (그러면 PK는 기본, 보조 인덱스에 모두 사용이 가능한가?)
    - 클러스터형 인덱스는 데이터 레코드의 정렬순서와 검색 키의 정렬순서가 같은 인덱스를 말한다.
    - 기본 인덱스는 보통 클러스터형 인덱스이며, 보조 인덱스는 키로 검색할 때 사용하기 때문에 비클러스터형 인덱스이다.


- 파일 : 한 개 이상의 디스크 블록으로 이루어진 페이지
- 페이지 : 일련의 레코드, 슬롯 페이지의 집합

새 레코드와 업데이트된 레코드는 key value 쌍으로 저장한다.
그리고 데이터를 즉시 페이지에서 삭제하지 않고, 삭제 관련된 메타 데이터를 저장한 delection marker를 사용한다.



데이터 레코드를 직접 참조하는지, 혹은 기본 키 인덱스를 통해 접근해야하는지는 장단점이 있다.

- 데이터를 직접 참조하면, 디스크 탐색 오버헤드가 줄지만 레코드 수정 시마다 포인터를 수정해야한다.
- 기본 인덱스를 통해 간접참조하면, 포인터 갱신비용은 줄지만 레코드 위치 찾는 과정이 추가된다.


## 버퍼링과 불변성, 순서화

스토리지 엔진에는 다양한 자료구조가 사용되는데, 그 중 공통점은 버퍼링을 사용하고 / 불변 파일을 사용하고 / 저장할 때 값의 순서를 유지한다는 점이다.



<br>
<br>


---
# 2. B-Tree

대부분의 가변자료 구조는 in-place 업데이트 방식

- CUD 시 데이터 저장 위치에 새 데이터를 바로쓰기

스토리지 엔진은 주로 여러 버전 레코드를 DB에 저장

하지만 쉽게 이해할 수 있도록 모든 키는 고유한 위치에 저장된 한 개의 데이터 레코드를 가리킨다고 가정

<br>

## 2-1. 이진 탐색트리 (BST)

정렬된 인메모리 자료구조, key:value 쌍 검색에 사용
- key와 2개의 자식 포인터가 저장된 여러 노드로 구성된다.
- 트리에는 루트 노드는 단 하나만 존재
    - 루트 노드는 탐색의 시작점이 된다.


BST의 각 노드는 왼쪽 / 오른쪽 서브트리로 탐색공간을 분할하고,
왼쪽 서브트리 키 < 노드 키 < 오른쪽 서브 트리 키와 같이 구성된다.


### 트리 밸런싱


노드 삽입 시에는 패턴이 없고, 값에 따라 불균형할 수 있다.
그래서 노드를 추가하거나 삭제한 후 트리를 회전하는 방법도 사용한다.

- 균형 트리 : 노드 N개, 높이 log2N, 높이 차이 최대 1
    - 각 노드에 2개의 포인터가 있어 탐색공간이 절반으로 줄어든다. O(log2N)
- 불균형 트리 : 최악의 경우 한 쪽으로만 치우쳐진 노드 O(N)


<br>

### 디스크 기반 스토리지용 트리


> 팬아웃(fanout) : 노드가 가질 수 있는 최대 자식 노드 개수

균형 트리는 팬아웃이 낮아 트리 밸런싱, 노드 재배치, 포인터 갱신이 자주 발생한다. -> 트리 유지비용이 높아 디스크 기반 자료구조로는 X

- 지역성 : 키 순서에 따라 삽입되지 않아 새 노드와 부모노드가 멀리 저장될 수 있다.
  (자식 포인터가 여러 디스크 페이지 가리킬 수 있음)
- 트리의 높이 : 팬아웃이 낮으면 인메모리는 유용하지만, 외부 스토리지 저장은 비효율적


디스크 저장에 적합한 트리는?

- 높은 팬아웃 : 인접한 키의 지역성을 높임
- 낮은 트리높이 : 트리 순회 중 디스크 탐색 횟수를 줄임

<br>
<br>

## 2-2. 디스크 기반 자료구조

디스크 기반 자료구조는 메모리에 데이터를 전부 저장할 수 없을 때 주로 사용

데이터 일부를 메모리에 캐시, 나머지는 효율적 접근하는 형태로 디스크에 저장한다.

<br>

### 하드 디스크 드라이브

- 탐색 작업이 읽기 부분의 대다수를 차지한다.
    - 디스크 회전 -> 읽기,쓰기용 헤드 이동

최소 전송단위는 setcor이며, 보통 512byte, 4Kb 사이의 크기를 가진다.

### 솔리브 스테이트 드라이브

물리적으로 움직이는 부품이 없고 메모리 cell로 구성되어있다.
- 셀 -> 스트링 -> 배열 -> 페이지 -> 블록 -> 플레인 -> 다이라고 부르며  SSD는 1개 이상으로 구성된다.
- 페이지 : 읽고 쓸 수 있는 가장 작은 단위
- 블록: 삭제할 수 있는 가장 작은 단위

TFL(Flash Translation Layer) : 실제 위치와 매핑, 비어있거나 삭제된 페이지를 관리하는 메모리 컨트롤러
- 지워도 되는 블록을 찾으면서 GC도 수행
- 이미 사용중인 페이지가 있으면 다른 위치로 옮기고, ID 매핑도 수정
- 사용하지 않는 블록은 재사용할 수 있도록 삭제

HDD, SDD는 데이터 청크 단위로 데이터를 참조한다. (개별 byte X)

- 대부분 운영체제는 블록 디바이스 추상화 계층에 존재
- 하드 디스크 내부구조를 추상화하고, I/O 작업을 내부적으로 버퍼링

SDD는 랜덤과 순차 I/O 레이턴시가 매우 작아서 둘 간의 구분이 중요하지 않다.

-  but prefetch 처럼 페이지 연속읽기, 내부 병렬처리로 인한 차이는 존재


GC는 백그라운드 작업이지만 쓰기 성능을 저하시킬 수 있음 -> 랜덤 쓰기, unaligned (비정렬) 쓰기 작업이 그렇다.

I/O 작업 수는 전체 블록단위로 쓰거나, 같은 블록 쓰기작업을 모아서 처리하면 줄일 수 있다.


<br>
<br>

## 2-3. 디스크 기반 자료구조

효율적인 디스크 기반 자료구조 설계가 어려운 이유

- 가장 작은 작업 단위가 블록
- 블록 특정 위치를 참조하려면 블록 전체를 읽어야한다.


디스크 기반 자료구조에서는 포인터를 직접 관리하는데, 포인터가 가리키는 주소를 직접 계산하고 명시적으로 따라간다.

- 디스크 오프셋은 사전에 계산된다.
    - 그렇지 않으면 메모리에 캐시된 다음 디스크로 플러시
- 자료구조에 긴 종속 관계 사슬이 만들어지면 유지관리가 어려워짐

따라서 전체 포인터 수를 제한, 저장 범위를 최소화하는 편이 좋다.

- 디스크 접근 횟수 최소화
- 내부구조 최적화, 지역성을 높여 페이지를 넘나드는 포인터 최소화

=> 팬아웃이 높고 높이가 낮을 때 이상적이다.
=> 근처에 있고, 탐색 횟수가 적다.



<br>
<br>

## 2-4. 유비쿼터스 B-Tree


** 최대 자식 수가 많아 팬아웃이 높고, 높이가 낮은 BST 기반 트리

*B-Tree는 키의 순서가 보장된다.*

- 노드 키를 기준으로 정렬, 저장
- 이진탐색 알고리즘으로 특정 키 검색 가능 -> 시간 복잡도 log 시간
- 노드에 수십, 수백개의 키를 저장하기 때문에 level 별로 디스크를 한 번만 탐색하면 된다.

### B-Tree 계층

B-Tree의 각 노드는 최대 N 개의 키, N+1 개의 자식 노드 포인터를 저장한다.

- root 노드 : 트리의 최상위 노드. 부모노드 없음
- 내부 노드 : 루트와 리프노드를 연결하는 모든 노드. 한 레벨 이상의 내부노드가 있다.
- leaf 노드 : 트리의 최하위 계층노드. 자식노드 없음
- 점유율(occupancy) : 보유 가능한 노드 용량과 실제 보유하고 있는 키 개수 비율

B-Tree에서 중요한 팬아웃은 높으면

- 트리 구조 변경비용을 낮출 수 있다.
- 키와 포인터를 같은 블록, 연속된 블록에 저장하니 불필요한 탐색을 줄일 수 있다. (지역성?)



### 구분 키

B-Tree 노드에 저장된 키를 구분 키, 혹은 divder cell이라고 부른다.

- 트리를 해당 키 범위의 서브트리로 분할함
- 키는 정렬되어있어 이진 검색 가능
- 높은 -> 낮은 레벨로 서브트리 포인터를 따라가며 키를 찾음
- 추후 삽입 및 업데이트 될 노드의 공간을 미리 확보해둔다.

이진트리와 달리 상향식 (리프 -> 위로) 트리 구성이고, 리프 노드가 많을수록 내부노드와 높이도 증가한다.


### B-Tree 탐색 시간복잡도

전체 노드 개수가 M개, 각 노드 별 N개의 키가 있고, 각 레벨은 이전 레벨보다 K배 많은 노드가 있다고 가정

- 블록 전송횟수 관점 : logn
    - 탐색 공간이 N의 비율로 감소한다.
    - 특정 키를 찾기 위해서는 최대 logkM 개의 페이지에 접근
- 블록 비교 횟수 관점 :  log2M
    - 각 노드 안에서는 이진탐색으로 키를 찾기 떄문에 로그 밑은 2
    - 비교할 때마다 탐색 공간이 절반으로 줄어들기 떄문에 log2M


### 탐색 알고리즘

탐색 : 루트 -> 리프 레벨까지 순회하여 특정 값을 찾는다.

- 특정 키/ 혹은 앞 키를 찾는 것이 목적
- 루트 노드부터 이진검색을 수행
    - 검색 키보다 큰 첫 번째 구분 키(인덱스 키)로 서브트리를 찾고 -> 리프노드까지  포인터 따라감
    - 대상 키를 반환하거나 / 존재하지 않으면 앞의 값을 반환
- 레벨이 낮아질 수록 검색 범위가 줄어든다.


### 키 개수

page 크기 = k

[BAYER72]
k~2k개의 키에 k+1~2k+1 개의 자식 노드를 가리키는 포인터 저장 가능
root page는 1~2k 개의 키
리프가 아닌 모든 page는 최대 I+1개의 키를 포함

... 결과는 동일하나 키와 자식 오프셋 수를 계산하는 방식은 다양하게 있다.

## 밸런싱 작업

### 노드 분할

새 노드를 삽입하려면 대상 리프 -> 삽입할 위치를 결정하여 key value 쌍을 추가한다. (업데이트도 동일)
리프 노드에 남은 공간이 없는 오버플로우 상태인 경우 *노드 분할*이 필요하다.


분할 조건

- 리프노드 : 노드에 최대 N개의 key value 쌍을 저장할 수 있고 / 새 값을 삽입할 때 용량 초과
- !리프노드 : 노드에 최대 N+1 개의 '포인터'를 저장할 수 있고 / 포인터 추가 시 용량 초과

승급 : 노드 분할은 새로운 노드를 할당하고, 키의 절반은 새 노드로 옮기면서 첫 번째 키와 포인터를 부모노드에 추가하는 방식
미드포인트 (분할지점) : 분할이 발생한 키

IF) 부모 노드에도 공간이 없으면, 부모도 분할한다.
IF) 트리에 용량이 부족하면, 루트 노드를 분할한다.

- 분할 지점의 키를 포함하는 새로운 루트 노드를 생성한다.
    - 기존 루트 노드는 다음 레벨로 강등되고, 트리 높이는 +1


1. 새로운 노드를 할당
2. 분할 노드 키의 절반을 새로운 노드로 복사
3. 새로운 키를 알맞은 노드에 삽입
4. 분할 노드의 부모 노드에 -> 분할 키, 새로운 노드 포인터를 추가


### 노드 병합

언더플로우 : 노드가 갖고 있는 값이 너무 적어지면, 형제 노드를 병합해야한다. (*키를 삭제하는 경우 대상 키가 포함된 리프노드 찾기 -> 삭제)

형제 노드 부모가 같고 + 한 노드로 합칠 수 있으면 병합.
그럴 수 없으면, 키를 두 노드로 재분배 및 리밸런싱


- 리프노드 : 노드에 최대 N개의 key value 쌍을 저장할 수 있고 / 두 노드의 총 쌍의 수 <= N
- !리프노드 : 노드에 최대 N+1 개의 포인터를 저장할 수 있고 / 두 노드의 포인터 수의 합 <= N+1

(키는 이미 삭제되었다고 가정하고 진행)
1. 모든 키를 오른쪽 -> 왼쪽으로 복사
2. 부모 노드에서 오른쪽 노드 포인터를 제거
3. 오른쪽 노드도 제거






